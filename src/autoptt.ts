// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.2
// source: src/autoptt.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "autoptt";

export enum ActivationMode {
  AUTOMATIC = 0,
  TAP_PTT = 1,
  MANUAL = 2,
  TAP_OPEN_MIC_TO_PTT = 3,
  MANUAL_OPEN_MIC_TO_PTT = 4,
  UNRECOGNIZED = -1,
}

export function activationModeFromJSON(object: any): ActivationMode {
  switch (object) {
    case 0:
    case "AUTOMATIC":
      return ActivationMode.AUTOMATIC;
    case 1:
    case "TAP_PTT":
      return ActivationMode.TAP_PTT;
    case 2:
    case "MANUAL":
      return ActivationMode.MANUAL;
    case 3:
    case "TAP_OPEN_MIC_TO_PTT":
      return ActivationMode.TAP_OPEN_MIC_TO_PTT;
    case 4:
    case "MANUAL_OPEN_MIC_TO_PTT":
      return ActivationMode.MANUAL_OPEN_MIC_TO_PTT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActivationMode.UNRECOGNIZED;
  }
}

export function activationModeToJSON(object: ActivationMode): string {
  switch (object) {
    case ActivationMode.AUTOMATIC:
      return "AUTOMATIC";
    case ActivationMode.TAP_PTT:
      return "TAP_PTT";
    case ActivationMode.MANUAL:
      return "MANUAL";
    case ActivationMode.TAP_OPEN_MIC_TO_PTT:
      return "TAP_OPEN_MIC_TO_PTT";
    case ActivationMode.MANUAL_OPEN_MIC_TO_PTT:
      return "MANUAL_OPEN_MIC_TO_PTT";
    case ActivationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MeterType {
  PEAK_VALUE_API = 0,
  CAPTURE_API = 1,
  UNRECOGNIZED = -1,
}

export function meterTypeFromJSON(object: any): MeterType {
  switch (object) {
    case 0:
    case "PEAK_VALUE_API":
      return MeterType.PEAK_VALUE_API;
    case 1:
    case "CAPTURE_API":
      return MeterType.CAPTURE_API;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MeterType.UNRECOGNIZED;
  }
}

export function meterTypeToJSON(object: MeterType): string {
  switch (object) {
    case MeterType.PEAK_VALUE_API:
      return "PEAK_VALUE_API";
    case MeterType.CAPTURE_API:
      return "CAPTURE_API";
    case MeterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StartOnBootType {
  NO = 0,
  YES = 1,
  YES_MINIMIZED = 2,
  UNRECOGNIZED = -1,
}

export function startOnBootTypeFromJSON(object: any): StartOnBootType {
  switch (object) {
    case 0:
    case "NO":
      return StartOnBootType.NO;
    case 1:
    case "YES":
      return StartOnBootType.YES;
    case 2:
    case "YES_MINIMIZED":
      return StartOnBootType.YES_MINIMIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StartOnBootType.UNRECOGNIZED;
  }
}

export function startOnBootTypeToJSON(object: StartOnBootType): string {
  switch (object) {
    case StartOnBootType.NO:
      return "NO";
    case StartOnBootType.YES:
      return "YES";
    case StartOnBootType.YES_MINIMIZED:
      return "YES_MINIMIZED";
    case StartOnBootType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ActivityState {
  INACTIVE = 0,
  ACTIVE = 1,
  ACTIVE_RELEASE_DELAY = 2,
  ACTIVE_TAP_ACTIVATION_WINDOW = 3,
  UNRECOGNIZED = -1,
}

export function activityStateFromJSON(object: any): ActivityState {
  switch (object) {
    case 0:
    case "INACTIVE":
      return ActivityState.INACTIVE;
    case 1:
    case "ACTIVE":
      return ActivityState.ACTIVE;
    case 2:
    case "ACTIVE_RELEASE_DELAY":
      return ActivityState.ACTIVE_RELEASE_DELAY;
    case 3:
    case "ACTIVE_TAP_ACTIVATION_WINDOW":
      return ActivityState.ACTIVE_TAP_ACTIVATION_WINDOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActivityState.UNRECOGNIZED;
  }
}

export function activityStateToJSON(object: ActivityState): string {
  switch (object) {
    case ActivityState.INACTIVE:
      return "INACTIVE";
    case ActivityState.ACTIVE:
      return "ACTIVE";
    case ActivityState.ACTIVE_RELEASE_DELAY:
      return "ACTIVE_RELEASE_DELAY";
    case ActivityState.ACTIVE_TAP_ACTIVATION_WINDOW:
      return "ACTIVE_TAP_ACTIVATION_WINDOW";
    case ActivityState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UpdaterState {
  IDLE = 0,
  UPDATING = 1,
  UPDATE_FAILED = 2,
  UPDATE_SUCCESS = 3,
  UNRECOGNIZED = -1,
}

export function updaterStateFromJSON(object: any): UpdaterState {
  switch (object) {
    case 0:
    case "IDLE":
      return UpdaterState.IDLE;
    case 1:
    case "UPDATING":
      return UpdaterState.UPDATING;
    case 2:
    case "UPDATE_FAILED":
      return UpdaterState.UPDATE_FAILED;
    case 3:
    case "UPDATE_SUCCESS":
      return UpdaterState.UPDATE_SUCCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpdaterState.UNRECOGNIZED;
  }
}

export function updaterStateToJSON(object: UpdaterState): string {
  switch (object) {
    case UpdaterState.IDLE:
      return "IDLE";
    case UpdaterState.UPDATING:
      return "UPDATING";
    case UpdaterState.UPDATE_FAILED:
      return "UPDATE_FAILED";
    case UpdaterState.UPDATE_SUCCESS:
      return "UPDATE_SUCCESS";
    case UpdaterState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AppEnabledState {
  ENABLED = 0,
  /** DISABLED_INVALID_LICENSE - Occures when the license is either invalid or the trial has expired. */
  DISABLED_INVALID_LICENSE = 1,
  /** DISABLED_BLOCKED_BY_GUI - Occurs when you're writing into a text box, or when you're biding a key. */
  DISABLED_BLOCKED_BY_GUI = 2,
  UNRECOGNIZED = -1,
}

export function appEnabledStateFromJSON(object: any): AppEnabledState {
  switch (object) {
    case 0:
    case "ENABLED":
      return AppEnabledState.ENABLED;
    case 1:
    case "DISABLED_INVALID_LICENSE":
      return AppEnabledState.DISABLED_INVALID_LICENSE;
    case 2:
    case "DISABLED_BLOCKED_BY_GUI":
      return AppEnabledState.DISABLED_BLOCKED_BY_GUI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AppEnabledState.UNRECOGNIZED;
  }
}

export function appEnabledStateToJSON(object: AppEnabledState): string {
  switch (object) {
    case AppEnabledState.ENABLED:
      return "ENABLED";
    case AppEnabledState.DISABLED_INVALID_LICENSE:
      return "DISABLED_INVALID_LICENSE";
    case AppEnabledState.DISABLED_BLOCKED_BY_GUI:
      return "DISABLED_BLOCKED_BY_GUI";
    case AppEnabledState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Settings {
  version: number;
  threshold: number;
  useDeactThreshold: boolean;
  deactThreshold: number;
  safe: boolean;
  safeIntervalMs: number;
  deprecatedUpdateIntervalMs: number;
  releaseDelayMs: number;
  activationMode: ActivationMode;
  meterType: MeterType;
  startOnBootType: StartOnBootType;
  /** --> device_name, device_uuid (v6) */
  deprecatedDeviceNameOrUuid: string;
  licenseKey: string;
  useSidekick: boolean;
  soundOnPttDown: Sound | undefined;
  soundOnPttUp: Sound | undefined;
  soundOnPushToMuteDown: Sound | undefined;
  soundOnPushToMuteUp: Sound | undefined;
  soundOnPushToMuteGlobalDown: Sound | undefined;
  soundOnPushToMuteGlobalUp: Sound | undefined;
  soundOnSetModeToVoiceActivity: Sound | undefined;
  soundOnSetModeToTap: Sound | undefined;
  soundOnSetModeToManual: Sound | undefined;
  soundOnSetModeToTapOpenMicToPtt: Sound | undefined;
  soundOnSetModeToManualOpenMicToPtt:
    | Sound
    | undefined;
  /** --> key_groups (v4) */
  pttSingle:
    | HotkeyV3
    | undefined;
  /** --> key_groups (v4) */
  keyPushToMuteSingle: HotkeyV3 | undefined;
  keyPushToMuteGlobal: HotkeyV3 | undefined;
  keySetModeToVoiceActivity: HotkeyV3 | undefined;
  keySetModeToTap: HotkeyV3 | undefined;
  keySetModeToManual: HotkeyV3 | undefined;
  keySetModeToTapOpenMicToPtt: HotkeyV3 | undefined;
  keySetModeToManualOpenMicToPtt: HotkeyV3 | undefined;
  keySwapModeBetweenManualAndVoiceActivity: HotkeyV3 | undefined;
  keySwapModeBetweenManualAndTap: HotkeyV3 | undefined;
  keySwapModeBetweenManualAndManualOpenMicToPtt:
    | HotkeyV3
    | undefined;
  /** --> key_groups (v4) */
  deprecatedExtraTriggerKeys: HotkeyV3[];
  minimizeToTray: boolean;
  openMicToPttConsumeInput: boolean;
  updateCheck: boolean;
  ipcAddr: string;
  overlayEnable: boolean;
  overlaySettings: OverlaySettings | undefined;
  deviceDisplayName: string;
  keyGroups: HotkeyGroup[];
  selectedTab: SelectedTab | undefined;
  useTapActivationWindow: boolean;
  tapActivationWindowMs: number;
  deviceName: string;
  deviceUuid: string;
  appVersion: number;
}

export interface Sound {
  enabled: boolean;
  file: string;
  volume: number;
}

export interface HotkeyV3 {
  vkCodes: number[];
}

export interface HotkeyGroup {
  displayName: string;
  pushToTalk: HotkeyV3 | undefined;
  pushToMute: HotkeyV3[];
  extraTriggers: HotkeyV3[];
}

export interface SelectedTab {
  general?: SelectedTabGeneral | undefined;
  device?: SelectedTabDevice | undefined;
}

export interface SelectedTabGeneral {
}

export interface SelectedTabDevice {
  deviceIndex: number;
}

export interface Ipc {
  serverHello?: IpcServerHello | undefined;
  activityStateChanged?: IpcActivityStateChanged | undefined;
  appEnabledStateChanged?: IpcAppEnabledStateChanged | undefined;
  currentValueChanged?: IpcCurrentValueChanged | undefined;
  muteStateChanged?: IpcMuteStateChanged | undefined;
  settingsChanged?: IpcSettingsChanged | undefined;
  sidekickConnected?: IpcSidekickConnected | undefined;
  sidekickDisconnected?: IpcSidekickDisconnected | undefined;
  updaterStateChanged?: IpcUpdaterStateChanged | undefined;
  updateCheckSuccess?: IpcUpdateCheckSuccess | undefined;
  updateCheckFailed?: IpcUpdateCheckFailed | undefined;
  guiDeviceChanged?: IpcGuiDeviceChanged | undefined;
  overlayHello?: IpcOverlayHello | undefined;
  clientConfigure?: IpcClientConfigure | undefined;
  requestRestart?: IpcRequestRestart | undefined;
  requestExit?: IpcRequestExit | undefined;
  requestUpdate?: IpcRequestUpdate | undefined;
  requestUpdateSettings?: IpcRequestUpdateSettings | undefined;
  requestPlaySfx?: IpcRequestPlaySfx | undefined;
  requestSwapActivationMode?: IpcRequestSwapActivationMode | undefined;
  requestSetPushToTalkState?: IpcRequestSetPushToTalkState | undefined;
  requestSetPushToMuteState?: IpcRequestSetPushToMuteState | undefined;
  requestSetPushToMuteGlobalState?: IpcRequestSetPushToMuteGlobalState | undefined;
}

export interface IpcActivityStateChanged {
  aggregateState: ActivityState;
  keyGroupStates: ActivityState[];
}

export interface IpcMuteStateChanged {
  isMuted: boolean;
}

export interface IpcSettingsChanged {
  settings: Settings | undefined;
}

export interface OverlaySettings {
  showWhenInactive: boolean;
  showModeText: boolean;
  showPttKeyName: boolean;
  isMovable: boolean;
  x: number;
  y: number;
}

export interface IpcOverlayHello {
}

export interface IpcSidekickConnected {
  port: string;
}

export interface IpcSidekickDisconnected {
}

export interface IpcRequestRestart {
}

export interface IpcRequestExit {
}

export interface IpcRequestUpdate {
}

export interface IpcRequestUpdateSettings {
  settings: Settings | undefined;
  forceLicenseCheck: boolean;
}

export interface IpcUpdaterStateChanged {
  state: UpdaterState;
  progressPct: number;
  message: string;
}

export interface IpcUpdateCheckSuccess {
  isNewer: boolean;
  latestVersion: string;
  changelog: string;
  downloadUrl: string;
  signatureUrl: string;
}

export interface IpcUpdateCheckFailed {
}

export interface IpcCurrentValueChanged {
  value: number;
}

export interface IpcMonitoringAllowedChanged {
  isAllowed: boolean;
}

export interface IpcRequestPlaySfx {
  sfx: number;
}

export interface IpcClientConfigure {
  /** Defaults to 0 (disabled). */
  currentValueUpdateRateMs: number;
  ipcVersion: number;
  ipcTag: string;
}

export interface IpcServerHello {
  /** SHOULD BE EQUAL TO CLIENT, otherwise no promises anything will work! */
  ipcVersion: number;
  /**
   * Format:  (major * 1000 * 1000) + (minor * 1000) + patch
   * Example: app version 1.2.3 --> 1002003
   */
  appVersion: number;
}

export interface IpcGuiDeviceChanged {
  deviceNameOrUuid: string;
}

export interface IpcAppEnabledStateChanged {
  state: AppEnabledState;
}

export interface IpcRequestSwapActivationMode {
  modes: ActivationMode[];
}

export interface IpcRequestSetPushToTalkState {
  keyGroupIndex: number;
  isDown: boolean;
}

export interface IpcRequestSetPushToMuteState {
  keyGroupIndex: number;
  isDown: boolean;
}

export interface IpcRequestSetPushToMuteGlobalState {
  isDown: boolean;
}

function createBaseSettings(): Settings {
  return {
    version: 0,
    threshold: 0,
    useDeactThreshold: false,
    deactThreshold: 0,
    safe: false,
    safeIntervalMs: 0,
    deprecatedUpdateIntervalMs: 0,
    releaseDelayMs: 0,
    activationMode: 0,
    meterType: 0,
    startOnBootType: 0,
    deprecatedDeviceNameOrUuid: "",
    licenseKey: "",
    useSidekick: false,
    soundOnPttDown: undefined,
    soundOnPttUp: undefined,
    soundOnPushToMuteDown: undefined,
    soundOnPushToMuteUp: undefined,
    soundOnPushToMuteGlobalDown: undefined,
    soundOnPushToMuteGlobalUp: undefined,
    soundOnSetModeToVoiceActivity: undefined,
    soundOnSetModeToTap: undefined,
    soundOnSetModeToManual: undefined,
    soundOnSetModeToTapOpenMicToPtt: undefined,
    soundOnSetModeToManualOpenMicToPtt: undefined,
    pttSingle: undefined,
    keyPushToMuteSingle: undefined,
    keyPushToMuteGlobal: undefined,
    keySetModeToVoiceActivity: undefined,
    keySetModeToTap: undefined,
    keySetModeToManual: undefined,
    keySetModeToTapOpenMicToPtt: undefined,
    keySetModeToManualOpenMicToPtt: undefined,
    keySwapModeBetweenManualAndVoiceActivity: undefined,
    keySwapModeBetweenManualAndTap: undefined,
    keySwapModeBetweenManualAndManualOpenMicToPtt: undefined,
    deprecatedExtraTriggerKeys: [],
    minimizeToTray: false,
    openMicToPttConsumeInput: false,
    updateCheck: false,
    ipcAddr: "",
    overlayEnable: false,
    overlaySettings: undefined,
    deviceDisplayName: "",
    keyGroups: [],
    selectedTab: undefined,
    useTapActivationWindow: false,
    tapActivationWindowMs: 0,
    deviceName: "",
    deviceUuid: "",
    appVersion: 0,
  };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.threshold !== 0) {
      writer.uint32(17).double(message.threshold);
    }
    if (message.useDeactThreshold !== false) {
      writer.uint32(24).bool(message.useDeactThreshold);
    }
    if (message.deactThreshold !== 0) {
      writer.uint32(33).double(message.deactThreshold);
    }
    if (message.safe !== false) {
      writer.uint32(40).bool(message.safe);
    }
    if (message.safeIntervalMs !== 0) {
      writer.uint32(48).uint32(message.safeIntervalMs);
    }
    if (message.deprecatedUpdateIntervalMs !== 0) {
      writer.uint32(56).uint32(message.deprecatedUpdateIntervalMs);
    }
    if (message.releaseDelayMs !== 0) {
      writer.uint32(64).uint32(message.releaseDelayMs);
    }
    if (message.activationMode !== 0) {
      writer.uint32(88).int32(message.activationMode);
    }
    if (message.meterType !== 0) {
      writer.uint32(96).int32(message.meterType);
    }
    if (message.startOnBootType !== 0) {
      writer.uint32(104).int32(message.startOnBootType);
    }
    if (message.deprecatedDeviceNameOrUuid !== "") {
      writer.uint32(114).string(message.deprecatedDeviceNameOrUuid);
    }
    if (message.licenseKey !== "") {
      writer.uint32(122).string(message.licenseKey);
    }
    if (message.useSidekick !== false) {
      writer.uint32(128).bool(message.useSidekick);
    }
    if (message.soundOnPttDown !== undefined) {
      Sound.encode(message.soundOnPttDown, writer.uint32(138).fork()).join();
    }
    if (message.soundOnPttUp !== undefined) {
      Sound.encode(message.soundOnPttUp, writer.uint32(146).fork()).join();
    }
    if (message.soundOnPushToMuteDown !== undefined) {
      Sound.encode(message.soundOnPushToMuteDown, writer.uint32(154).fork()).join();
    }
    if (message.soundOnPushToMuteUp !== undefined) {
      Sound.encode(message.soundOnPushToMuteUp, writer.uint32(162).fork()).join();
    }
    if (message.soundOnPushToMuteGlobalDown !== undefined) {
      Sound.encode(message.soundOnPushToMuteGlobalDown, writer.uint32(170).fork()).join();
    }
    if (message.soundOnPushToMuteGlobalUp !== undefined) {
      Sound.encode(message.soundOnPushToMuteGlobalUp, writer.uint32(178).fork()).join();
    }
    if (message.soundOnSetModeToVoiceActivity !== undefined) {
      Sound.encode(message.soundOnSetModeToVoiceActivity, writer.uint32(186).fork()).join();
    }
    if (message.soundOnSetModeToTap !== undefined) {
      Sound.encode(message.soundOnSetModeToTap, writer.uint32(194).fork()).join();
    }
    if (message.soundOnSetModeToManual !== undefined) {
      Sound.encode(message.soundOnSetModeToManual, writer.uint32(202).fork()).join();
    }
    if (message.soundOnSetModeToTapOpenMicToPtt !== undefined) {
      Sound.encode(message.soundOnSetModeToTapOpenMicToPtt, writer.uint32(210).fork()).join();
    }
    if (message.soundOnSetModeToManualOpenMicToPtt !== undefined) {
      Sound.encode(message.soundOnSetModeToManualOpenMicToPtt, writer.uint32(218).fork()).join();
    }
    if (message.pttSingle !== undefined) {
      HotkeyV3.encode(message.pttSingle, writer.uint32(82).fork()).join();
    }
    if (message.keyPushToMuteSingle !== undefined) {
      HotkeyV3.encode(message.keyPushToMuteSingle, writer.uint32(226).fork()).join();
    }
    if (message.keyPushToMuteGlobal !== undefined) {
      HotkeyV3.encode(message.keyPushToMuteGlobal, writer.uint32(234).fork()).join();
    }
    if (message.keySetModeToVoiceActivity !== undefined) {
      HotkeyV3.encode(message.keySetModeToVoiceActivity, writer.uint32(242).fork()).join();
    }
    if (message.keySetModeToTap !== undefined) {
      HotkeyV3.encode(message.keySetModeToTap, writer.uint32(250).fork()).join();
    }
    if (message.keySetModeToManual !== undefined) {
      HotkeyV3.encode(message.keySetModeToManual, writer.uint32(258).fork()).join();
    }
    if (message.keySetModeToTapOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.keySetModeToTapOpenMicToPtt, writer.uint32(266).fork()).join();
    }
    if (message.keySetModeToManualOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.keySetModeToManualOpenMicToPtt, writer.uint32(274).fork()).join();
    }
    if (message.keySwapModeBetweenManualAndVoiceActivity !== undefined) {
      HotkeyV3.encode(message.keySwapModeBetweenManualAndVoiceActivity, writer.uint32(282).fork()).join();
    }
    if (message.keySwapModeBetweenManualAndTap !== undefined) {
      HotkeyV3.encode(message.keySwapModeBetweenManualAndTap, writer.uint32(290).fork()).join();
    }
    if (message.keySwapModeBetweenManualAndManualOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.keySwapModeBetweenManualAndManualOpenMicToPtt, writer.uint32(298).fork()).join();
    }
    for (const v of message.deprecatedExtraTriggerKeys) {
      HotkeyV3.encode(v!, writer.uint32(306).fork()).join();
    }
    if (message.minimizeToTray !== false) {
      writer.uint32(312).bool(message.minimizeToTray);
    }
    if (message.openMicToPttConsumeInput !== false) {
      writer.uint32(320).bool(message.openMicToPttConsumeInput);
    }
    if (message.updateCheck !== false) {
      writer.uint32(328).bool(message.updateCheck);
    }
    if (message.ipcAddr !== "") {
      writer.uint32(338).string(message.ipcAddr);
    }
    if (message.overlayEnable !== false) {
      writer.uint32(344).bool(message.overlayEnable);
    }
    if (message.overlaySettings !== undefined) {
      OverlaySettings.encode(message.overlaySettings, writer.uint32(354).fork()).join();
    }
    if (message.deviceDisplayName !== "") {
      writer.uint32(362).string(message.deviceDisplayName);
    }
    for (const v of message.keyGroups) {
      HotkeyGroup.encode(v!, writer.uint32(402).fork()).join();
    }
    if (message.selectedTab !== undefined) {
      SelectedTab.encode(message.selectedTab, writer.uint32(410).fork()).join();
    }
    if (message.useTapActivationWindow !== false) {
      writer.uint32(416).bool(message.useTapActivationWindow);
    }
    if (message.tapActivationWindowMs !== 0) {
      writer.uint32(424).uint32(message.tapActivationWindowMs);
    }
    if (message.deviceName !== "") {
      writer.uint32(450).string(message.deviceName);
    }
    if (message.deviceUuid !== "") {
      writer.uint32(458).string(message.deviceUuid);
    }
    if (message.appVersion !== 0) {
      writer.uint32(464).uint64(message.appVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.threshold = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.useDeactThreshold = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.deactThreshold = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.safe = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.safeIntervalMs = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.deprecatedUpdateIntervalMs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.releaseDelayMs = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.activationMode = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.meterType = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.startOnBootType = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.deprecatedDeviceNameOrUuid = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.licenseKey = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.useSidekick = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.soundOnPttDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.soundOnPttUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.soundOnPushToMuteDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.soundOnPushToMuteUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.soundOnPushToMuteGlobalDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.soundOnPushToMuteGlobalUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.soundOnSetModeToVoiceActivity = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.soundOnSetModeToTap = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.soundOnSetModeToManual = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.soundOnSetModeToTapOpenMicToPtt = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.soundOnSetModeToManualOpenMicToPtt = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pttSingle = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.keyPushToMuteSingle = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.keyPushToMuteGlobal = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.keySetModeToVoiceActivity = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.keySetModeToTap = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.keySetModeToManual = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.keySetModeToTapOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.keySetModeToManualOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.keySwapModeBetweenManualAndVoiceActivity = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.keySwapModeBetweenManualAndTap = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.keySwapModeBetweenManualAndManualOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.deprecatedExtraTriggerKeys.push(HotkeyV3.decode(reader, reader.uint32()));
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.minimizeToTray = reader.bool();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.openMicToPttConsumeInput = reader.bool();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.updateCheck = reader.bool();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.ipcAddr = reader.string();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.overlayEnable = reader.bool();
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.overlaySettings = OverlaySettings.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.deviceDisplayName = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.keyGroups.push(HotkeyGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.selectedTab = SelectedTab.decode(reader, reader.uint32());
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.useTapActivationWindow = reader.bool();
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }

          message.tapActivationWindowMs = reader.uint32();
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.deviceUuid = reader.string();
          continue;
        }
        case 58: {
          if (tag !== 464) {
            break;
          }

          message.appVersion = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      useDeactThreshold: isSet(object.useDeactThreshold) ? globalThis.Boolean(object.useDeactThreshold) : false,
      deactThreshold: isSet(object.deactThreshold) ? globalThis.Number(object.deactThreshold) : 0,
      safe: isSet(object.safe) ? globalThis.Boolean(object.safe) : false,
      safeIntervalMs: isSet(object.safeIntervalMs) ? globalThis.Number(object.safeIntervalMs) : 0,
      deprecatedUpdateIntervalMs: isSet(object.deprecatedUpdateIntervalMs)
        ? globalThis.Number(object.deprecatedUpdateIntervalMs)
        : 0,
      releaseDelayMs: isSet(object.releaseDelayMs) ? globalThis.Number(object.releaseDelayMs) : 0,
      activationMode: isSet(object.activationMode) ? activationModeFromJSON(object.activationMode) : 0,
      meterType: isSet(object.meterType) ? meterTypeFromJSON(object.meterType) : 0,
      startOnBootType: isSet(object.startOnBootType) ? startOnBootTypeFromJSON(object.startOnBootType) : 0,
      deprecatedDeviceNameOrUuid: isSet(object.deprecatedDeviceNameOrUuid)
        ? globalThis.String(object.deprecatedDeviceNameOrUuid)
        : "",
      licenseKey: isSet(object.licenseKey) ? globalThis.String(object.licenseKey) : "",
      useSidekick: isSet(object.useSidekick) ? globalThis.Boolean(object.useSidekick) : false,
      soundOnPttDown: isSet(object.soundOnPttDown) ? Sound.fromJSON(object.soundOnPttDown) : undefined,
      soundOnPttUp: isSet(object.soundOnPttUp) ? Sound.fromJSON(object.soundOnPttUp) : undefined,
      soundOnPushToMuteDown: isSet(object.soundOnPushToMuteDown)
        ? Sound.fromJSON(object.soundOnPushToMuteDown)
        : undefined,
      soundOnPushToMuteUp: isSet(object.soundOnPushToMuteUp) ? Sound.fromJSON(object.soundOnPushToMuteUp) : undefined,
      soundOnPushToMuteGlobalDown: isSet(object.soundOnPushToMuteGlobalDown)
        ? Sound.fromJSON(object.soundOnPushToMuteGlobalDown)
        : undefined,
      soundOnPushToMuteGlobalUp: isSet(object.soundOnPushToMuteGlobalUp)
        ? Sound.fromJSON(object.soundOnPushToMuteGlobalUp)
        : undefined,
      soundOnSetModeToVoiceActivity: isSet(object.soundOnSetModeToVoiceActivity)
        ? Sound.fromJSON(object.soundOnSetModeToVoiceActivity)
        : undefined,
      soundOnSetModeToTap: isSet(object.soundOnSetModeToTap) ? Sound.fromJSON(object.soundOnSetModeToTap) : undefined,
      soundOnSetModeToManual: isSet(object.soundOnSetModeToManual)
        ? Sound.fromJSON(object.soundOnSetModeToManual)
        : undefined,
      soundOnSetModeToTapOpenMicToPtt: isSet(object.soundOnSetModeToTapOpenMicToPtt)
        ? Sound.fromJSON(object.soundOnSetModeToTapOpenMicToPtt)
        : undefined,
      soundOnSetModeToManualOpenMicToPtt: isSet(object.soundOnSetModeToManualOpenMicToPtt)
        ? Sound.fromJSON(object.soundOnSetModeToManualOpenMicToPtt)
        : undefined,
      pttSingle: isSet(object.pttSingle) ? HotkeyV3.fromJSON(object.pttSingle) : undefined,
      keyPushToMuteSingle: isSet(object.keyPushToMuteSingle)
        ? HotkeyV3.fromJSON(object.keyPushToMuteSingle)
        : undefined,
      keyPushToMuteGlobal: isSet(object.keyPushToMuteGlobal)
        ? HotkeyV3.fromJSON(object.keyPushToMuteGlobal)
        : undefined,
      keySetModeToVoiceActivity: isSet(object.keySetModeToVoiceActivity)
        ? HotkeyV3.fromJSON(object.keySetModeToVoiceActivity)
        : undefined,
      keySetModeToTap: isSet(object.keySetModeToTap) ? HotkeyV3.fromJSON(object.keySetModeToTap) : undefined,
      keySetModeToManual: isSet(object.keySetModeToManual) ? HotkeyV3.fromJSON(object.keySetModeToManual) : undefined,
      keySetModeToTapOpenMicToPtt: isSet(object.keySetModeToTapOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.keySetModeToTapOpenMicToPtt)
        : undefined,
      keySetModeToManualOpenMicToPtt: isSet(object.keySetModeToManualOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.keySetModeToManualOpenMicToPtt)
        : undefined,
      keySwapModeBetweenManualAndVoiceActivity: isSet(object.keySwapModeBetweenManualAndVoiceActivity)
        ? HotkeyV3.fromJSON(object.keySwapModeBetweenManualAndVoiceActivity)
        : undefined,
      keySwapModeBetweenManualAndTap: isSet(object.keySwapModeBetweenManualAndTap)
        ? HotkeyV3.fromJSON(object.keySwapModeBetweenManualAndTap)
        : undefined,
      keySwapModeBetweenManualAndManualOpenMicToPtt: isSet(object.keySwapModeBetweenManualAndManualOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.keySwapModeBetweenManualAndManualOpenMicToPtt)
        : undefined,
      deprecatedExtraTriggerKeys: globalThis.Array.isArray(object?.deprecatedExtraTriggerKeys)
        ? object.deprecatedExtraTriggerKeys.map((e: any) => HotkeyV3.fromJSON(e))
        : [],
      minimizeToTray: isSet(object.minimizeToTray) ? globalThis.Boolean(object.minimizeToTray) : false,
      openMicToPttConsumeInput: isSet(object.openMicToPttConsumeInput)
        ? globalThis.Boolean(object.openMicToPttConsumeInput)
        : false,
      updateCheck: isSet(object.updateCheck) ? globalThis.Boolean(object.updateCheck) : false,
      ipcAddr: isSet(object.ipcAddr) ? globalThis.String(object.ipcAddr) : "",
      overlayEnable: isSet(object.overlayEnable) ? globalThis.Boolean(object.overlayEnable) : false,
      overlaySettings: isSet(object.overlaySettings) ? OverlaySettings.fromJSON(object.overlaySettings) : undefined,
      deviceDisplayName: isSet(object.deviceDisplayName) ? globalThis.String(object.deviceDisplayName) : "",
      keyGroups: globalThis.Array.isArray(object?.keyGroups)
        ? object.keyGroups.map((e: any) => HotkeyGroup.fromJSON(e))
        : [],
      selectedTab: isSet(object.selectedTab) ? SelectedTab.fromJSON(object.selectedTab) : undefined,
      useTapActivationWindow: isSet(object.useTapActivationWindow)
        ? globalThis.Boolean(object.useTapActivationWindow)
        : false,
      tapActivationWindowMs: isSet(object.tapActivationWindowMs) ? globalThis.Number(object.tapActivationWindowMs) : 0,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
      deviceUuid: isSet(object.deviceUuid) ? globalThis.String(object.deviceUuid) : "",
      appVersion: isSet(object.appVersion) ? globalThis.Number(object.appVersion) : 0,
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    if (message.useDeactThreshold !== false) {
      obj.useDeactThreshold = message.useDeactThreshold;
    }
    if (message.deactThreshold !== 0) {
      obj.deactThreshold = message.deactThreshold;
    }
    if (message.safe !== false) {
      obj.safe = message.safe;
    }
    if (message.safeIntervalMs !== 0) {
      obj.safeIntervalMs = Math.round(message.safeIntervalMs);
    }
    if (message.deprecatedUpdateIntervalMs !== 0) {
      obj.deprecatedUpdateIntervalMs = Math.round(message.deprecatedUpdateIntervalMs);
    }
    if (message.releaseDelayMs !== 0) {
      obj.releaseDelayMs = Math.round(message.releaseDelayMs);
    }
    if (message.activationMode !== 0) {
      obj.activationMode = activationModeToJSON(message.activationMode);
    }
    if (message.meterType !== 0) {
      obj.meterType = meterTypeToJSON(message.meterType);
    }
    if (message.startOnBootType !== 0) {
      obj.startOnBootType = startOnBootTypeToJSON(message.startOnBootType);
    }
    if (message.deprecatedDeviceNameOrUuid !== "") {
      obj.deprecatedDeviceNameOrUuid = message.deprecatedDeviceNameOrUuid;
    }
    if (message.licenseKey !== "") {
      obj.licenseKey = message.licenseKey;
    }
    if (message.useSidekick !== false) {
      obj.useSidekick = message.useSidekick;
    }
    if (message.soundOnPttDown !== undefined) {
      obj.soundOnPttDown = Sound.toJSON(message.soundOnPttDown);
    }
    if (message.soundOnPttUp !== undefined) {
      obj.soundOnPttUp = Sound.toJSON(message.soundOnPttUp);
    }
    if (message.soundOnPushToMuteDown !== undefined) {
      obj.soundOnPushToMuteDown = Sound.toJSON(message.soundOnPushToMuteDown);
    }
    if (message.soundOnPushToMuteUp !== undefined) {
      obj.soundOnPushToMuteUp = Sound.toJSON(message.soundOnPushToMuteUp);
    }
    if (message.soundOnPushToMuteGlobalDown !== undefined) {
      obj.soundOnPushToMuteGlobalDown = Sound.toJSON(message.soundOnPushToMuteGlobalDown);
    }
    if (message.soundOnPushToMuteGlobalUp !== undefined) {
      obj.soundOnPushToMuteGlobalUp = Sound.toJSON(message.soundOnPushToMuteGlobalUp);
    }
    if (message.soundOnSetModeToVoiceActivity !== undefined) {
      obj.soundOnSetModeToVoiceActivity = Sound.toJSON(message.soundOnSetModeToVoiceActivity);
    }
    if (message.soundOnSetModeToTap !== undefined) {
      obj.soundOnSetModeToTap = Sound.toJSON(message.soundOnSetModeToTap);
    }
    if (message.soundOnSetModeToManual !== undefined) {
      obj.soundOnSetModeToManual = Sound.toJSON(message.soundOnSetModeToManual);
    }
    if (message.soundOnSetModeToTapOpenMicToPtt !== undefined) {
      obj.soundOnSetModeToTapOpenMicToPtt = Sound.toJSON(message.soundOnSetModeToTapOpenMicToPtt);
    }
    if (message.soundOnSetModeToManualOpenMicToPtt !== undefined) {
      obj.soundOnSetModeToManualOpenMicToPtt = Sound.toJSON(message.soundOnSetModeToManualOpenMicToPtt);
    }
    if (message.pttSingle !== undefined) {
      obj.pttSingle = HotkeyV3.toJSON(message.pttSingle);
    }
    if (message.keyPushToMuteSingle !== undefined) {
      obj.keyPushToMuteSingle = HotkeyV3.toJSON(message.keyPushToMuteSingle);
    }
    if (message.keyPushToMuteGlobal !== undefined) {
      obj.keyPushToMuteGlobal = HotkeyV3.toJSON(message.keyPushToMuteGlobal);
    }
    if (message.keySetModeToVoiceActivity !== undefined) {
      obj.keySetModeToVoiceActivity = HotkeyV3.toJSON(message.keySetModeToVoiceActivity);
    }
    if (message.keySetModeToTap !== undefined) {
      obj.keySetModeToTap = HotkeyV3.toJSON(message.keySetModeToTap);
    }
    if (message.keySetModeToManual !== undefined) {
      obj.keySetModeToManual = HotkeyV3.toJSON(message.keySetModeToManual);
    }
    if (message.keySetModeToTapOpenMicToPtt !== undefined) {
      obj.keySetModeToTapOpenMicToPtt = HotkeyV3.toJSON(message.keySetModeToTapOpenMicToPtt);
    }
    if (message.keySetModeToManualOpenMicToPtt !== undefined) {
      obj.keySetModeToManualOpenMicToPtt = HotkeyV3.toJSON(message.keySetModeToManualOpenMicToPtt);
    }
    if (message.keySwapModeBetweenManualAndVoiceActivity !== undefined) {
      obj.keySwapModeBetweenManualAndVoiceActivity = HotkeyV3.toJSON(message.keySwapModeBetweenManualAndVoiceActivity);
    }
    if (message.keySwapModeBetweenManualAndTap !== undefined) {
      obj.keySwapModeBetweenManualAndTap = HotkeyV3.toJSON(message.keySwapModeBetweenManualAndTap);
    }
    if (message.keySwapModeBetweenManualAndManualOpenMicToPtt !== undefined) {
      obj.keySwapModeBetweenManualAndManualOpenMicToPtt = HotkeyV3.toJSON(
        message.keySwapModeBetweenManualAndManualOpenMicToPtt,
      );
    }
    if (message.deprecatedExtraTriggerKeys?.length) {
      obj.deprecatedExtraTriggerKeys = message.deprecatedExtraTriggerKeys.map((e) => HotkeyV3.toJSON(e));
    }
    if (message.minimizeToTray !== false) {
      obj.minimizeToTray = message.minimizeToTray;
    }
    if (message.openMicToPttConsumeInput !== false) {
      obj.openMicToPttConsumeInput = message.openMicToPttConsumeInput;
    }
    if (message.updateCheck !== false) {
      obj.updateCheck = message.updateCheck;
    }
    if (message.ipcAddr !== "") {
      obj.ipcAddr = message.ipcAddr;
    }
    if (message.overlayEnable !== false) {
      obj.overlayEnable = message.overlayEnable;
    }
    if (message.overlaySettings !== undefined) {
      obj.overlaySettings = OverlaySettings.toJSON(message.overlaySettings);
    }
    if (message.deviceDisplayName !== "") {
      obj.deviceDisplayName = message.deviceDisplayName;
    }
    if (message.keyGroups?.length) {
      obj.keyGroups = message.keyGroups.map((e) => HotkeyGroup.toJSON(e));
    }
    if (message.selectedTab !== undefined) {
      obj.selectedTab = SelectedTab.toJSON(message.selectedTab);
    }
    if (message.useTapActivationWindow !== false) {
      obj.useTapActivationWindow = message.useTapActivationWindow;
    }
    if (message.tapActivationWindowMs !== 0) {
      obj.tapActivationWindowMs = Math.round(message.tapActivationWindowMs);
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    if (message.deviceUuid !== "") {
      obj.deviceUuid = message.deviceUuid;
    }
    if (message.appVersion !== 0) {
      obj.appVersion = Math.round(message.appVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Settings>, I>>(base?: I): Settings {
    return Settings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settings>, I>>(object: I): Settings {
    const message = createBaseSettings();
    message.version = object.version ?? 0;
    message.threshold = object.threshold ?? 0;
    message.useDeactThreshold = object.useDeactThreshold ?? false;
    message.deactThreshold = object.deactThreshold ?? 0;
    message.safe = object.safe ?? false;
    message.safeIntervalMs = object.safeIntervalMs ?? 0;
    message.deprecatedUpdateIntervalMs = object.deprecatedUpdateIntervalMs ?? 0;
    message.releaseDelayMs = object.releaseDelayMs ?? 0;
    message.activationMode = object.activationMode ?? 0;
    message.meterType = object.meterType ?? 0;
    message.startOnBootType = object.startOnBootType ?? 0;
    message.deprecatedDeviceNameOrUuid = object.deprecatedDeviceNameOrUuid ?? "";
    message.licenseKey = object.licenseKey ?? "";
    message.useSidekick = object.useSidekick ?? false;
    message.soundOnPttDown = (object.soundOnPttDown !== undefined && object.soundOnPttDown !== null)
      ? Sound.fromPartial(object.soundOnPttDown)
      : undefined;
    message.soundOnPttUp = (object.soundOnPttUp !== undefined && object.soundOnPttUp !== null)
      ? Sound.fromPartial(object.soundOnPttUp)
      : undefined;
    message.soundOnPushToMuteDown =
      (object.soundOnPushToMuteDown !== undefined && object.soundOnPushToMuteDown !== null)
        ? Sound.fromPartial(object.soundOnPushToMuteDown)
        : undefined;
    message.soundOnPushToMuteUp = (object.soundOnPushToMuteUp !== undefined && object.soundOnPushToMuteUp !== null)
      ? Sound.fromPartial(object.soundOnPushToMuteUp)
      : undefined;
    message.soundOnPushToMuteGlobalDown =
      (object.soundOnPushToMuteGlobalDown !== undefined && object.soundOnPushToMuteGlobalDown !== null)
        ? Sound.fromPartial(object.soundOnPushToMuteGlobalDown)
        : undefined;
    message.soundOnPushToMuteGlobalUp =
      (object.soundOnPushToMuteGlobalUp !== undefined && object.soundOnPushToMuteGlobalUp !== null)
        ? Sound.fromPartial(object.soundOnPushToMuteGlobalUp)
        : undefined;
    message.soundOnSetModeToVoiceActivity =
      (object.soundOnSetModeToVoiceActivity !== undefined && object.soundOnSetModeToVoiceActivity !== null)
        ? Sound.fromPartial(object.soundOnSetModeToVoiceActivity)
        : undefined;
    message.soundOnSetModeToTap = (object.soundOnSetModeToTap !== undefined && object.soundOnSetModeToTap !== null)
      ? Sound.fromPartial(object.soundOnSetModeToTap)
      : undefined;
    message.soundOnSetModeToManual =
      (object.soundOnSetModeToManual !== undefined && object.soundOnSetModeToManual !== null)
        ? Sound.fromPartial(object.soundOnSetModeToManual)
        : undefined;
    message.soundOnSetModeToTapOpenMicToPtt =
      (object.soundOnSetModeToTapOpenMicToPtt !== undefined && object.soundOnSetModeToTapOpenMicToPtt !== null)
        ? Sound.fromPartial(object.soundOnSetModeToTapOpenMicToPtt)
        : undefined;
    message.soundOnSetModeToManualOpenMicToPtt =
      (object.soundOnSetModeToManualOpenMicToPtt !== undefined && object.soundOnSetModeToManualOpenMicToPtt !== null)
        ? Sound.fromPartial(object.soundOnSetModeToManualOpenMicToPtt)
        : undefined;
    message.pttSingle = (object.pttSingle !== undefined && object.pttSingle !== null)
      ? HotkeyV3.fromPartial(object.pttSingle)
      : undefined;
    message.keyPushToMuteSingle = (object.keyPushToMuteSingle !== undefined && object.keyPushToMuteSingle !== null)
      ? HotkeyV3.fromPartial(object.keyPushToMuteSingle)
      : undefined;
    message.keyPushToMuteGlobal = (object.keyPushToMuteGlobal !== undefined && object.keyPushToMuteGlobal !== null)
      ? HotkeyV3.fromPartial(object.keyPushToMuteGlobal)
      : undefined;
    message.keySetModeToVoiceActivity =
      (object.keySetModeToVoiceActivity !== undefined && object.keySetModeToVoiceActivity !== null)
        ? HotkeyV3.fromPartial(object.keySetModeToVoiceActivity)
        : undefined;
    message.keySetModeToTap = (object.keySetModeToTap !== undefined && object.keySetModeToTap !== null)
      ? HotkeyV3.fromPartial(object.keySetModeToTap)
      : undefined;
    message.keySetModeToManual = (object.keySetModeToManual !== undefined && object.keySetModeToManual !== null)
      ? HotkeyV3.fromPartial(object.keySetModeToManual)
      : undefined;
    message.keySetModeToTapOpenMicToPtt =
      (object.keySetModeToTapOpenMicToPtt !== undefined && object.keySetModeToTapOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.keySetModeToTapOpenMicToPtt)
        : undefined;
    message.keySetModeToManualOpenMicToPtt =
      (object.keySetModeToManualOpenMicToPtt !== undefined && object.keySetModeToManualOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.keySetModeToManualOpenMicToPtt)
        : undefined;
    message.keySwapModeBetweenManualAndVoiceActivity =
      (object.keySwapModeBetweenManualAndVoiceActivity !== undefined &&
          object.keySwapModeBetweenManualAndVoiceActivity !== null)
        ? HotkeyV3.fromPartial(object.keySwapModeBetweenManualAndVoiceActivity)
        : undefined;
    message.keySwapModeBetweenManualAndTap =
      (object.keySwapModeBetweenManualAndTap !== undefined && object.keySwapModeBetweenManualAndTap !== null)
        ? HotkeyV3.fromPartial(object.keySwapModeBetweenManualAndTap)
        : undefined;
    message.keySwapModeBetweenManualAndManualOpenMicToPtt =
      (object.keySwapModeBetweenManualAndManualOpenMicToPtt !== undefined &&
          object.keySwapModeBetweenManualAndManualOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.keySwapModeBetweenManualAndManualOpenMicToPtt)
        : undefined;
    message.deprecatedExtraTriggerKeys = object.deprecatedExtraTriggerKeys?.map((e) => HotkeyV3.fromPartial(e)) || [];
    message.minimizeToTray = object.minimizeToTray ?? false;
    message.openMicToPttConsumeInput = object.openMicToPttConsumeInput ?? false;
    message.updateCheck = object.updateCheck ?? false;
    message.ipcAddr = object.ipcAddr ?? "";
    message.overlayEnable = object.overlayEnable ?? false;
    message.overlaySettings = (object.overlaySettings !== undefined && object.overlaySettings !== null)
      ? OverlaySettings.fromPartial(object.overlaySettings)
      : undefined;
    message.deviceDisplayName = object.deviceDisplayName ?? "";
    message.keyGroups = object.keyGroups?.map((e) => HotkeyGroup.fromPartial(e)) || [];
    message.selectedTab = (object.selectedTab !== undefined && object.selectedTab !== null)
      ? SelectedTab.fromPartial(object.selectedTab)
      : undefined;
    message.useTapActivationWindow = object.useTapActivationWindow ?? false;
    message.tapActivationWindowMs = object.tapActivationWindowMs ?? 0;
    message.deviceName = object.deviceName ?? "";
    message.deviceUuid = object.deviceUuid ?? "";
    message.appVersion = object.appVersion ?? 0;
    return message;
  },
};

function createBaseSound(): Sound {
  return { enabled: false, file: "", volume: 0 };
}

export const Sound: MessageFns<Sound> = {
  encode(message: Sound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.file !== "") {
      writer.uint32(18).string(message.file);
    }
    if (message.volume !== 0) {
      writer.uint32(25).double(message.volume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.file = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.volume = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sound {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0,
    };
  },

  toJSON(message: Sound): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (message.volume !== 0) {
      obj.volume = message.volume;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Sound>, I>>(base?: I): Sound {
    return Sound.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Sound>, I>>(object: I): Sound {
    const message = createBaseSound();
    message.enabled = object.enabled ?? false;
    message.file = object.file ?? "";
    message.volume = object.volume ?? 0;
    return message;
  },
};

function createBaseHotkeyV3(): HotkeyV3 {
  return { vkCodes: [] };
}

export const HotkeyV3: MessageFns<HotkeyV3> = {
  encode(message: HotkeyV3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.vkCodes) {
      writer.uint32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotkeyV3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotkeyV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.vkCodes.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vkCodes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotkeyV3 {
    return {
      vkCodes: globalThis.Array.isArray(object?.vkCodes) ? object.vkCodes.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: HotkeyV3): unknown {
    const obj: any = {};
    if (message.vkCodes?.length) {
      obj.vkCodes = message.vkCodes.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HotkeyV3>, I>>(base?: I): HotkeyV3 {
    return HotkeyV3.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HotkeyV3>, I>>(object: I): HotkeyV3 {
    const message = createBaseHotkeyV3();
    message.vkCodes = object.vkCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseHotkeyGroup(): HotkeyGroup {
  return { displayName: "", pushToTalk: undefined, pushToMute: [], extraTriggers: [] };
}

export const HotkeyGroup: MessageFns<HotkeyGroup> = {
  encode(message: HotkeyGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.pushToTalk !== undefined) {
      HotkeyV3.encode(message.pushToTalk, writer.uint32(18).fork()).join();
    }
    for (const v of message.pushToMute) {
      HotkeyV3.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.extraTriggers) {
      HotkeyV3.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotkeyGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotkeyGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pushToTalk = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pushToMute.push(HotkeyV3.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extraTriggers.push(HotkeyV3.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotkeyGroup {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      pushToTalk: isSet(object.pushToTalk) ? HotkeyV3.fromJSON(object.pushToTalk) : undefined,
      pushToMute: globalThis.Array.isArray(object?.pushToMute)
        ? object.pushToMute.map((e: any) => HotkeyV3.fromJSON(e))
        : [],
      extraTriggers: globalThis.Array.isArray(object?.extraTriggers)
        ? object.extraTriggers.map((e: any) => HotkeyV3.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HotkeyGroup): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.pushToTalk !== undefined) {
      obj.pushToTalk = HotkeyV3.toJSON(message.pushToTalk);
    }
    if (message.pushToMute?.length) {
      obj.pushToMute = message.pushToMute.map((e) => HotkeyV3.toJSON(e));
    }
    if (message.extraTriggers?.length) {
      obj.extraTriggers = message.extraTriggers.map((e) => HotkeyV3.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HotkeyGroup>, I>>(base?: I): HotkeyGroup {
    return HotkeyGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HotkeyGroup>, I>>(object: I): HotkeyGroup {
    const message = createBaseHotkeyGroup();
    message.displayName = object.displayName ?? "";
    message.pushToTalk = (object.pushToTalk !== undefined && object.pushToTalk !== null)
      ? HotkeyV3.fromPartial(object.pushToTalk)
      : undefined;
    message.pushToMute = object.pushToMute?.map((e) => HotkeyV3.fromPartial(e)) || [];
    message.extraTriggers = object.extraTriggers?.map((e) => HotkeyV3.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSelectedTab(): SelectedTab {
  return { general: undefined, device: undefined };
}

export const SelectedTab: MessageFns<SelectedTab> = {
  encode(message: SelectedTab, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.general !== undefined) {
      SelectedTabGeneral.encode(message.general, writer.uint32(10).fork()).join();
    }
    if (message.device !== undefined) {
      SelectedTabDevice.encode(message.device, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedTab {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedTab();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.general = SelectedTabGeneral.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.device = SelectedTabDevice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectedTab {
    return {
      general: isSet(object.general) ? SelectedTabGeneral.fromJSON(object.general) : undefined,
      device: isSet(object.device) ? SelectedTabDevice.fromJSON(object.device) : undefined,
    };
  },

  toJSON(message: SelectedTab): unknown {
    const obj: any = {};
    if (message.general !== undefined) {
      obj.general = SelectedTabGeneral.toJSON(message.general);
    }
    if (message.device !== undefined) {
      obj.device = SelectedTabDevice.toJSON(message.device);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectedTab>, I>>(base?: I): SelectedTab {
    return SelectedTab.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectedTab>, I>>(object: I): SelectedTab {
    const message = createBaseSelectedTab();
    message.general = (object.general !== undefined && object.general !== null)
      ? SelectedTabGeneral.fromPartial(object.general)
      : undefined;
    message.device = (object.device !== undefined && object.device !== null)
      ? SelectedTabDevice.fromPartial(object.device)
      : undefined;
    return message;
  },
};

function createBaseSelectedTabGeneral(): SelectedTabGeneral {
  return {};
}

export const SelectedTabGeneral: MessageFns<SelectedTabGeneral> = {
  encode(_: SelectedTabGeneral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedTabGeneral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedTabGeneral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SelectedTabGeneral {
    return {};
  },

  toJSON(_: SelectedTabGeneral): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectedTabGeneral>, I>>(base?: I): SelectedTabGeneral {
    return SelectedTabGeneral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectedTabGeneral>, I>>(_: I): SelectedTabGeneral {
    const message = createBaseSelectedTabGeneral();
    return message;
  },
};

function createBaseSelectedTabDevice(): SelectedTabDevice {
  return { deviceIndex: 0 };
}

export const SelectedTabDevice: MessageFns<SelectedTabDevice> = {
  encode(message: SelectedTabDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceIndex !== 0) {
      writer.uint32(8).int32(message.deviceIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedTabDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedTabDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deviceIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectedTabDevice {
    return { deviceIndex: isSet(object.deviceIndex) ? globalThis.Number(object.deviceIndex) : 0 };
  },

  toJSON(message: SelectedTabDevice): unknown {
    const obj: any = {};
    if (message.deviceIndex !== 0) {
      obj.deviceIndex = Math.round(message.deviceIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectedTabDevice>, I>>(base?: I): SelectedTabDevice {
    return SelectedTabDevice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectedTabDevice>, I>>(object: I): SelectedTabDevice {
    const message = createBaseSelectedTabDevice();
    message.deviceIndex = object.deviceIndex ?? 0;
    return message;
  },
};

function createBaseIpc(): Ipc {
  return {
    serverHello: undefined,
    activityStateChanged: undefined,
    appEnabledStateChanged: undefined,
    currentValueChanged: undefined,
    muteStateChanged: undefined,
    settingsChanged: undefined,
    sidekickConnected: undefined,
    sidekickDisconnected: undefined,
    updaterStateChanged: undefined,
    updateCheckSuccess: undefined,
    updateCheckFailed: undefined,
    guiDeviceChanged: undefined,
    overlayHello: undefined,
    clientConfigure: undefined,
    requestRestart: undefined,
    requestExit: undefined,
    requestUpdate: undefined,
    requestUpdateSettings: undefined,
    requestPlaySfx: undefined,
    requestSwapActivationMode: undefined,
    requestSetPushToTalkState: undefined,
    requestSetPushToMuteState: undefined,
    requestSetPushToMuteGlobalState: undefined,
  };
}

export const Ipc: MessageFns<Ipc> = {
  encode(message: Ipc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverHello !== undefined) {
      IpcServerHello.encode(message.serverHello, writer.uint32(186).fork()).join();
    }
    if (message.activityStateChanged !== undefined) {
      IpcActivityStateChanged.encode(message.activityStateChanged, writer.uint32(10).fork()).join();
    }
    if (message.appEnabledStateChanged !== undefined) {
      IpcAppEnabledStateChanged.encode(message.appEnabledStateChanged, writer.uint32(202).fork()).join();
    }
    if (message.currentValueChanged !== undefined) {
      IpcCurrentValueChanged.encode(message.currentValueChanged, writer.uint32(146).fork()).join();
    }
    if (message.muteStateChanged !== undefined) {
      IpcMuteStateChanged.encode(message.muteStateChanged, writer.uint32(18).fork()).join();
    }
    if (message.settingsChanged !== undefined) {
      IpcSettingsChanged.encode(message.settingsChanged, writer.uint32(26).fork()).join();
    }
    if (message.sidekickConnected !== undefined) {
      IpcSidekickConnected.encode(message.sidekickConnected, writer.uint32(58).fork()).join();
    }
    if (message.sidekickDisconnected !== undefined) {
      IpcSidekickDisconnected.encode(message.sidekickDisconnected, writer.uint32(66).fork()).join();
    }
    if (message.updaterStateChanged !== undefined) {
      IpcUpdaterStateChanged.encode(message.updaterStateChanged, writer.uint32(114).fork()).join();
    }
    if (message.updateCheckSuccess !== undefined) {
      IpcUpdateCheckSuccess.encode(message.updateCheckSuccess, writer.uint32(122).fork()).join();
    }
    if (message.updateCheckFailed !== undefined) {
      IpcUpdateCheckFailed.encode(message.updateCheckFailed, writer.uint32(130).fork()).join();
    }
    if (message.guiDeviceChanged !== undefined) {
      IpcGuiDeviceChanged.encode(message.guiDeviceChanged, writer.uint32(194).fork()).join();
    }
    if (message.overlayHello !== undefined) {
      IpcOverlayHello.encode(message.overlayHello, writer.uint32(34).fork()).join();
    }
    if (message.clientConfigure !== undefined) {
      IpcClientConfigure.encode(message.clientConfigure, writer.uint32(178).fork()).join();
    }
    if (message.requestRestart !== undefined) {
      IpcRequestRestart.encode(message.requestRestart, writer.uint32(82).fork()).join();
    }
    if (message.requestExit !== undefined) {
      IpcRequestExit.encode(message.requestExit, writer.uint32(90).fork()).join();
    }
    if (message.requestUpdate !== undefined) {
      IpcRequestUpdate.encode(message.requestUpdate, writer.uint32(98).fork()).join();
    }
    if (message.requestUpdateSettings !== undefined) {
      IpcRequestUpdateSettings.encode(message.requestUpdateSettings, writer.uint32(106).fork()).join();
    }
    if (message.requestPlaySfx !== undefined) {
      IpcRequestPlaySfx.encode(message.requestPlaySfx, writer.uint32(170).fork()).join();
    }
    if (message.requestSwapActivationMode !== undefined) {
      IpcRequestSwapActivationMode.encode(message.requestSwapActivationMode, writer.uint32(210).fork()).join();
    }
    if (message.requestSetPushToTalkState !== undefined) {
      IpcRequestSetPushToTalkState.encode(message.requestSetPushToTalkState, writer.uint32(218).fork()).join();
    }
    if (message.requestSetPushToMuteState !== undefined) {
      IpcRequestSetPushToMuteState.encode(message.requestSetPushToMuteState, writer.uint32(226).fork()).join();
    }
    if (message.requestSetPushToMuteGlobalState !== undefined) {
      IpcRequestSetPushToMuteGlobalState.encode(message.requestSetPushToMuteGlobalState, writer.uint32(234).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ipc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.serverHello = IpcServerHello.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.activityStateChanged = IpcActivityStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.appEnabledStateChanged = IpcAppEnabledStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.currentValueChanged = IpcCurrentValueChanged.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.muteStateChanged = IpcMuteStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.settingsChanged = IpcSettingsChanged.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sidekickConnected = IpcSidekickConnected.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sidekickDisconnected = IpcSidekickDisconnected.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updaterStateChanged = IpcUpdaterStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updateCheckSuccess = IpcUpdateCheckSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updateCheckFailed = IpcUpdateCheckFailed.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.guiDeviceChanged = IpcGuiDeviceChanged.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.overlayHello = IpcOverlayHello.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.clientConfigure = IpcClientConfigure.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requestRestart = IpcRequestRestart.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.requestExit = IpcRequestExit.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.requestUpdate = IpcRequestUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.requestUpdateSettings = IpcRequestUpdateSettings.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.requestPlaySfx = IpcRequestPlaySfx.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.requestSwapActivationMode = IpcRequestSwapActivationMode.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.requestSetPushToTalkState = IpcRequestSetPushToTalkState.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.requestSetPushToMuteState = IpcRequestSetPushToMuteState.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.requestSetPushToMuteGlobalState = IpcRequestSetPushToMuteGlobalState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ipc {
    return {
      serverHello: isSet(object.serverHello) ? IpcServerHello.fromJSON(object.serverHello) : undefined,
      activityStateChanged: isSet(object.activityStateChanged)
        ? IpcActivityStateChanged.fromJSON(object.activityStateChanged)
        : undefined,
      appEnabledStateChanged: isSet(object.appEnabledStateChanged)
        ? IpcAppEnabledStateChanged.fromJSON(object.appEnabledStateChanged)
        : undefined,
      currentValueChanged: isSet(object.currentValueChanged)
        ? IpcCurrentValueChanged.fromJSON(object.currentValueChanged)
        : undefined,
      muteStateChanged: isSet(object.muteStateChanged)
        ? IpcMuteStateChanged.fromJSON(object.muteStateChanged)
        : undefined,
      settingsChanged: isSet(object.settingsChanged) ? IpcSettingsChanged.fromJSON(object.settingsChanged) : undefined,
      sidekickConnected: isSet(object.sidekickConnected)
        ? IpcSidekickConnected.fromJSON(object.sidekickConnected)
        : undefined,
      sidekickDisconnected: isSet(object.sidekickDisconnected)
        ? IpcSidekickDisconnected.fromJSON(object.sidekickDisconnected)
        : undefined,
      updaterStateChanged: isSet(object.updaterStateChanged)
        ? IpcUpdaterStateChanged.fromJSON(object.updaterStateChanged)
        : undefined,
      updateCheckSuccess: isSet(object.updateCheckSuccess)
        ? IpcUpdateCheckSuccess.fromJSON(object.updateCheckSuccess)
        : undefined,
      updateCheckFailed: isSet(object.updateCheckFailed)
        ? IpcUpdateCheckFailed.fromJSON(object.updateCheckFailed)
        : undefined,
      guiDeviceChanged: isSet(object.guiDeviceChanged)
        ? IpcGuiDeviceChanged.fromJSON(object.guiDeviceChanged)
        : undefined,
      overlayHello: isSet(object.overlayHello) ? IpcOverlayHello.fromJSON(object.overlayHello) : undefined,
      clientConfigure: isSet(object.clientConfigure) ? IpcClientConfigure.fromJSON(object.clientConfigure) : undefined,
      requestRestart: isSet(object.requestRestart) ? IpcRequestRestart.fromJSON(object.requestRestart) : undefined,
      requestExit: isSet(object.requestExit) ? IpcRequestExit.fromJSON(object.requestExit) : undefined,
      requestUpdate: isSet(object.requestUpdate) ? IpcRequestUpdate.fromJSON(object.requestUpdate) : undefined,
      requestUpdateSettings: isSet(object.requestUpdateSettings)
        ? IpcRequestUpdateSettings.fromJSON(object.requestUpdateSettings)
        : undefined,
      requestPlaySfx: isSet(object.requestPlaySfx) ? IpcRequestPlaySfx.fromJSON(object.requestPlaySfx) : undefined,
      requestSwapActivationMode: isSet(object.requestSwapActivationMode)
        ? IpcRequestSwapActivationMode.fromJSON(object.requestSwapActivationMode)
        : undefined,
      requestSetPushToTalkState: isSet(object.requestSetPushToTalkState)
        ? IpcRequestSetPushToTalkState.fromJSON(object.requestSetPushToTalkState)
        : undefined,
      requestSetPushToMuteState: isSet(object.requestSetPushToMuteState)
        ? IpcRequestSetPushToMuteState.fromJSON(object.requestSetPushToMuteState)
        : undefined,
      requestSetPushToMuteGlobalState: isSet(object.requestSetPushToMuteGlobalState)
        ? IpcRequestSetPushToMuteGlobalState.fromJSON(object.requestSetPushToMuteGlobalState)
        : undefined,
    };
  },

  toJSON(message: Ipc): unknown {
    const obj: any = {};
    if (message.serverHello !== undefined) {
      obj.serverHello = IpcServerHello.toJSON(message.serverHello);
    }
    if (message.activityStateChanged !== undefined) {
      obj.activityStateChanged = IpcActivityStateChanged.toJSON(message.activityStateChanged);
    }
    if (message.appEnabledStateChanged !== undefined) {
      obj.appEnabledStateChanged = IpcAppEnabledStateChanged.toJSON(message.appEnabledStateChanged);
    }
    if (message.currentValueChanged !== undefined) {
      obj.currentValueChanged = IpcCurrentValueChanged.toJSON(message.currentValueChanged);
    }
    if (message.muteStateChanged !== undefined) {
      obj.muteStateChanged = IpcMuteStateChanged.toJSON(message.muteStateChanged);
    }
    if (message.settingsChanged !== undefined) {
      obj.settingsChanged = IpcSettingsChanged.toJSON(message.settingsChanged);
    }
    if (message.sidekickConnected !== undefined) {
      obj.sidekickConnected = IpcSidekickConnected.toJSON(message.sidekickConnected);
    }
    if (message.sidekickDisconnected !== undefined) {
      obj.sidekickDisconnected = IpcSidekickDisconnected.toJSON(message.sidekickDisconnected);
    }
    if (message.updaterStateChanged !== undefined) {
      obj.updaterStateChanged = IpcUpdaterStateChanged.toJSON(message.updaterStateChanged);
    }
    if (message.updateCheckSuccess !== undefined) {
      obj.updateCheckSuccess = IpcUpdateCheckSuccess.toJSON(message.updateCheckSuccess);
    }
    if (message.updateCheckFailed !== undefined) {
      obj.updateCheckFailed = IpcUpdateCheckFailed.toJSON(message.updateCheckFailed);
    }
    if (message.guiDeviceChanged !== undefined) {
      obj.guiDeviceChanged = IpcGuiDeviceChanged.toJSON(message.guiDeviceChanged);
    }
    if (message.overlayHello !== undefined) {
      obj.overlayHello = IpcOverlayHello.toJSON(message.overlayHello);
    }
    if (message.clientConfigure !== undefined) {
      obj.clientConfigure = IpcClientConfigure.toJSON(message.clientConfigure);
    }
    if (message.requestRestart !== undefined) {
      obj.requestRestart = IpcRequestRestart.toJSON(message.requestRestart);
    }
    if (message.requestExit !== undefined) {
      obj.requestExit = IpcRequestExit.toJSON(message.requestExit);
    }
    if (message.requestUpdate !== undefined) {
      obj.requestUpdate = IpcRequestUpdate.toJSON(message.requestUpdate);
    }
    if (message.requestUpdateSettings !== undefined) {
      obj.requestUpdateSettings = IpcRequestUpdateSettings.toJSON(message.requestUpdateSettings);
    }
    if (message.requestPlaySfx !== undefined) {
      obj.requestPlaySfx = IpcRequestPlaySfx.toJSON(message.requestPlaySfx);
    }
    if (message.requestSwapActivationMode !== undefined) {
      obj.requestSwapActivationMode = IpcRequestSwapActivationMode.toJSON(message.requestSwapActivationMode);
    }
    if (message.requestSetPushToTalkState !== undefined) {
      obj.requestSetPushToTalkState = IpcRequestSetPushToTalkState.toJSON(message.requestSetPushToTalkState);
    }
    if (message.requestSetPushToMuteState !== undefined) {
      obj.requestSetPushToMuteState = IpcRequestSetPushToMuteState.toJSON(message.requestSetPushToMuteState);
    }
    if (message.requestSetPushToMuteGlobalState !== undefined) {
      obj.requestSetPushToMuteGlobalState = IpcRequestSetPushToMuteGlobalState.toJSON(
        message.requestSetPushToMuteGlobalState,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ipc>, I>>(base?: I): Ipc {
    return Ipc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ipc>, I>>(object: I): Ipc {
    const message = createBaseIpc();
    message.serverHello = (object.serverHello !== undefined && object.serverHello !== null)
      ? IpcServerHello.fromPartial(object.serverHello)
      : undefined;
    message.activityStateChanged = (object.activityStateChanged !== undefined && object.activityStateChanged !== null)
      ? IpcActivityStateChanged.fromPartial(object.activityStateChanged)
      : undefined;
    message.appEnabledStateChanged =
      (object.appEnabledStateChanged !== undefined && object.appEnabledStateChanged !== null)
        ? IpcAppEnabledStateChanged.fromPartial(object.appEnabledStateChanged)
        : undefined;
    message.currentValueChanged = (object.currentValueChanged !== undefined && object.currentValueChanged !== null)
      ? IpcCurrentValueChanged.fromPartial(object.currentValueChanged)
      : undefined;
    message.muteStateChanged = (object.muteStateChanged !== undefined && object.muteStateChanged !== null)
      ? IpcMuteStateChanged.fromPartial(object.muteStateChanged)
      : undefined;
    message.settingsChanged = (object.settingsChanged !== undefined && object.settingsChanged !== null)
      ? IpcSettingsChanged.fromPartial(object.settingsChanged)
      : undefined;
    message.sidekickConnected = (object.sidekickConnected !== undefined && object.sidekickConnected !== null)
      ? IpcSidekickConnected.fromPartial(object.sidekickConnected)
      : undefined;
    message.sidekickDisconnected = (object.sidekickDisconnected !== undefined && object.sidekickDisconnected !== null)
      ? IpcSidekickDisconnected.fromPartial(object.sidekickDisconnected)
      : undefined;
    message.updaterStateChanged = (object.updaterStateChanged !== undefined && object.updaterStateChanged !== null)
      ? IpcUpdaterStateChanged.fromPartial(object.updaterStateChanged)
      : undefined;
    message.updateCheckSuccess = (object.updateCheckSuccess !== undefined && object.updateCheckSuccess !== null)
      ? IpcUpdateCheckSuccess.fromPartial(object.updateCheckSuccess)
      : undefined;
    message.updateCheckFailed = (object.updateCheckFailed !== undefined && object.updateCheckFailed !== null)
      ? IpcUpdateCheckFailed.fromPartial(object.updateCheckFailed)
      : undefined;
    message.guiDeviceChanged = (object.guiDeviceChanged !== undefined && object.guiDeviceChanged !== null)
      ? IpcGuiDeviceChanged.fromPartial(object.guiDeviceChanged)
      : undefined;
    message.overlayHello = (object.overlayHello !== undefined && object.overlayHello !== null)
      ? IpcOverlayHello.fromPartial(object.overlayHello)
      : undefined;
    message.clientConfigure = (object.clientConfigure !== undefined && object.clientConfigure !== null)
      ? IpcClientConfigure.fromPartial(object.clientConfigure)
      : undefined;
    message.requestRestart = (object.requestRestart !== undefined && object.requestRestart !== null)
      ? IpcRequestRestart.fromPartial(object.requestRestart)
      : undefined;
    message.requestExit = (object.requestExit !== undefined && object.requestExit !== null)
      ? IpcRequestExit.fromPartial(object.requestExit)
      : undefined;
    message.requestUpdate = (object.requestUpdate !== undefined && object.requestUpdate !== null)
      ? IpcRequestUpdate.fromPartial(object.requestUpdate)
      : undefined;
    message.requestUpdateSettings =
      (object.requestUpdateSettings !== undefined && object.requestUpdateSettings !== null)
        ? IpcRequestUpdateSettings.fromPartial(object.requestUpdateSettings)
        : undefined;
    message.requestPlaySfx = (object.requestPlaySfx !== undefined && object.requestPlaySfx !== null)
      ? IpcRequestPlaySfx.fromPartial(object.requestPlaySfx)
      : undefined;
    message.requestSwapActivationMode =
      (object.requestSwapActivationMode !== undefined && object.requestSwapActivationMode !== null)
        ? IpcRequestSwapActivationMode.fromPartial(object.requestSwapActivationMode)
        : undefined;
    message.requestSetPushToTalkState =
      (object.requestSetPushToTalkState !== undefined && object.requestSetPushToTalkState !== null)
        ? IpcRequestSetPushToTalkState.fromPartial(object.requestSetPushToTalkState)
        : undefined;
    message.requestSetPushToMuteState =
      (object.requestSetPushToMuteState !== undefined && object.requestSetPushToMuteState !== null)
        ? IpcRequestSetPushToMuteState.fromPartial(object.requestSetPushToMuteState)
        : undefined;
    message.requestSetPushToMuteGlobalState =
      (object.requestSetPushToMuteGlobalState !== undefined && object.requestSetPushToMuteGlobalState !== null)
        ? IpcRequestSetPushToMuteGlobalState.fromPartial(object.requestSetPushToMuteGlobalState)
        : undefined;
    return message;
  },
};

function createBaseIpcActivityStateChanged(): IpcActivityStateChanged {
  return { aggregateState: 0, keyGroupStates: [] };
}

export const IpcActivityStateChanged: MessageFns<IpcActivityStateChanged> = {
  encode(message: IpcActivityStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregateState !== 0) {
      writer.uint32(8).int32(message.aggregateState);
    }
    writer.uint32(18).fork();
    for (const v of message.keyGroupStates) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcActivityStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcActivityStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.aggregateState = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.keyGroupStates.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keyGroupStates.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcActivityStateChanged {
    return {
      aggregateState: isSet(object.aggregateState) ? activityStateFromJSON(object.aggregateState) : 0,
      keyGroupStates: globalThis.Array.isArray(object?.keyGroupStates)
        ? object.keyGroupStates.map((e: any) => activityStateFromJSON(e))
        : [],
    };
  },

  toJSON(message: IpcActivityStateChanged): unknown {
    const obj: any = {};
    if (message.aggregateState !== 0) {
      obj.aggregateState = activityStateToJSON(message.aggregateState);
    }
    if (message.keyGroupStates?.length) {
      obj.keyGroupStates = message.keyGroupStates.map((e) => activityStateToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcActivityStateChanged>, I>>(base?: I): IpcActivityStateChanged {
    return IpcActivityStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcActivityStateChanged>, I>>(object: I): IpcActivityStateChanged {
    const message = createBaseIpcActivityStateChanged();
    message.aggregateState = object.aggregateState ?? 0;
    message.keyGroupStates = object.keyGroupStates?.map((e) => e) || [];
    return message;
  },
};

function createBaseIpcMuteStateChanged(): IpcMuteStateChanged {
  return { isMuted: false };
}

export const IpcMuteStateChanged: MessageFns<IpcMuteStateChanged> = {
  encode(message: IpcMuteStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMuted !== false) {
      writer.uint32(8).bool(message.isMuted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcMuteStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcMuteStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMuted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcMuteStateChanged {
    return { isMuted: isSet(object.isMuted) ? globalThis.Boolean(object.isMuted) : false };
  },

  toJSON(message: IpcMuteStateChanged): unknown {
    const obj: any = {};
    if (message.isMuted !== false) {
      obj.isMuted = message.isMuted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcMuteStateChanged>, I>>(base?: I): IpcMuteStateChanged {
    return IpcMuteStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcMuteStateChanged>, I>>(object: I): IpcMuteStateChanged {
    const message = createBaseIpcMuteStateChanged();
    message.isMuted = object.isMuted ?? false;
    return message;
  },
};

function createBaseIpcSettingsChanged(): IpcSettingsChanged {
  return { settings: undefined };
}

export const IpcSettingsChanged: MessageFns<IpcSettingsChanged> = {
  encode(message: IpcSettingsChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcSettingsChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcSettingsChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcSettingsChanged {
    return { settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined };
  },

  toJSON(message: IpcSettingsChanged): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcSettingsChanged>, I>>(base?: I): IpcSettingsChanged {
    return IpcSettingsChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcSettingsChanged>, I>>(object: I): IpcSettingsChanged {
    const message = createBaseIpcSettingsChanged();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseOverlaySettings(): OverlaySettings {
  return { showWhenInactive: false, showModeText: false, showPttKeyName: false, isMovable: false, x: 0, y: 0 };
}

export const OverlaySettings: MessageFns<OverlaySettings> = {
  encode(message: OverlaySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.showWhenInactive !== false) {
      writer.uint32(8).bool(message.showWhenInactive);
    }
    if (message.showModeText !== false) {
      writer.uint32(16).bool(message.showModeText);
    }
    if (message.showPttKeyName !== false) {
      writer.uint32(24).bool(message.showPttKeyName);
    }
    if (message.isMovable !== false) {
      writer.uint32(32).bool(message.isMovable);
    }
    if (message.x !== 0) {
      writer.uint32(40).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(48).int32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverlaySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlaySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.showWhenInactive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.showModeText = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.showPttKeyName = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isMovable = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverlaySettings {
    return {
      showWhenInactive: isSet(object.showWhenInactive) ? globalThis.Boolean(object.showWhenInactive) : false,
      showModeText: isSet(object.showModeText) ? globalThis.Boolean(object.showModeText) : false,
      showPttKeyName: isSet(object.showPttKeyName) ? globalThis.Boolean(object.showPttKeyName) : false,
      isMovable: isSet(object.isMovable) ? globalThis.Boolean(object.isMovable) : false,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: OverlaySettings): unknown {
    const obj: any = {};
    if (message.showWhenInactive !== false) {
      obj.showWhenInactive = message.showWhenInactive;
    }
    if (message.showModeText !== false) {
      obj.showModeText = message.showModeText;
    }
    if (message.showPttKeyName !== false) {
      obj.showPttKeyName = message.showPttKeyName;
    }
    if (message.isMovable !== false) {
      obj.isMovable = message.isMovable;
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverlaySettings>, I>>(base?: I): OverlaySettings {
    return OverlaySettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverlaySettings>, I>>(object: I): OverlaySettings {
    const message = createBaseOverlaySettings();
    message.showWhenInactive = object.showWhenInactive ?? false;
    message.showModeText = object.showModeText ?? false;
    message.showPttKeyName = object.showPttKeyName ?? false;
    message.isMovable = object.isMovable ?? false;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseIpcOverlayHello(): IpcOverlayHello {
  return {};
}

export const IpcOverlayHello: MessageFns<IpcOverlayHello> = {
  encode(_: IpcOverlayHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcOverlayHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcOverlayHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcOverlayHello {
    return {};
  },

  toJSON(_: IpcOverlayHello): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcOverlayHello>, I>>(base?: I): IpcOverlayHello {
    return IpcOverlayHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcOverlayHello>, I>>(_: I): IpcOverlayHello {
    const message = createBaseIpcOverlayHello();
    return message;
  },
};

function createBaseIpcSidekickConnected(): IpcSidekickConnected {
  return { port: "" };
}

export const IpcSidekickConnected: MessageFns<IpcSidekickConnected> = {
  encode(message: IpcSidekickConnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== "") {
      writer.uint32(10).string(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcSidekickConnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcSidekickConnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.port = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcSidekickConnected {
    return { port: isSet(object.port) ? globalThis.String(object.port) : "" };
  },

  toJSON(message: IpcSidekickConnected): unknown {
    const obj: any = {};
    if (message.port !== "") {
      obj.port = message.port;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcSidekickConnected>, I>>(base?: I): IpcSidekickConnected {
    return IpcSidekickConnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcSidekickConnected>, I>>(object: I): IpcSidekickConnected {
    const message = createBaseIpcSidekickConnected();
    message.port = object.port ?? "";
    return message;
  },
};

function createBaseIpcSidekickDisconnected(): IpcSidekickDisconnected {
  return {};
}

export const IpcSidekickDisconnected: MessageFns<IpcSidekickDisconnected> = {
  encode(_: IpcSidekickDisconnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcSidekickDisconnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcSidekickDisconnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcSidekickDisconnected {
    return {};
  },

  toJSON(_: IpcSidekickDisconnected): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcSidekickDisconnected>, I>>(base?: I): IpcSidekickDisconnected {
    return IpcSidekickDisconnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcSidekickDisconnected>, I>>(_: I): IpcSidekickDisconnected {
    const message = createBaseIpcSidekickDisconnected();
    return message;
  },
};

function createBaseIpcRequestRestart(): IpcRequestRestart {
  return {};
}

export const IpcRequestRestart: MessageFns<IpcRequestRestart> = {
  encode(_: IpcRequestRestart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestRestart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestRestart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcRequestRestart {
    return {};
  },

  toJSON(_: IpcRequestRestart): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestRestart>, I>>(base?: I): IpcRequestRestart {
    return IpcRequestRestart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestRestart>, I>>(_: I): IpcRequestRestart {
    const message = createBaseIpcRequestRestart();
    return message;
  },
};

function createBaseIpcRequestExit(): IpcRequestExit {
  return {};
}

export const IpcRequestExit: MessageFns<IpcRequestExit> = {
  encode(_: IpcRequestExit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestExit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestExit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcRequestExit {
    return {};
  },

  toJSON(_: IpcRequestExit): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestExit>, I>>(base?: I): IpcRequestExit {
    return IpcRequestExit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestExit>, I>>(_: I): IpcRequestExit {
    const message = createBaseIpcRequestExit();
    return message;
  },
};

function createBaseIpcRequestUpdate(): IpcRequestUpdate {
  return {};
}

export const IpcRequestUpdate: MessageFns<IpcRequestUpdate> = {
  encode(_: IpcRequestUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcRequestUpdate {
    return {};
  },

  toJSON(_: IpcRequestUpdate): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestUpdate>, I>>(base?: I): IpcRequestUpdate {
    return IpcRequestUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestUpdate>, I>>(_: I): IpcRequestUpdate {
    const message = createBaseIpcRequestUpdate();
    return message;
  },
};

function createBaseIpcRequestUpdateSettings(): IpcRequestUpdateSettings {
  return { settings: undefined, forceLicenseCheck: false };
}

export const IpcRequestUpdateSettings: MessageFns<IpcRequestUpdateSettings> = {
  encode(message: IpcRequestUpdateSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    if (message.forceLicenseCheck !== false) {
      writer.uint32(16).bool(message.forceLicenseCheck);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestUpdateSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestUpdateSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.forceLicenseCheck = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestUpdateSettings {
    return {
      settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined,
      forceLicenseCheck: isSet(object.forceLicenseCheck) ? globalThis.Boolean(object.forceLicenseCheck) : false,
    };
  },

  toJSON(message: IpcRequestUpdateSettings): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    if (message.forceLicenseCheck !== false) {
      obj.forceLicenseCheck = message.forceLicenseCheck;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestUpdateSettings>, I>>(base?: I): IpcRequestUpdateSettings {
    return IpcRequestUpdateSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestUpdateSettings>, I>>(object: I): IpcRequestUpdateSettings {
    const message = createBaseIpcRequestUpdateSettings();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    message.forceLicenseCheck = object.forceLicenseCheck ?? false;
    return message;
  },
};

function createBaseIpcUpdaterStateChanged(): IpcUpdaterStateChanged {
  return { state: 0, progressPct: 0, message: "" };
}

export const IpcUpdaterStateChanged: MessageFns<IpcUpdaterStateChanged> = {
  encode(message: IpcUpdaterStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.progressPct !== 0) {
      writer.uint32(16).uint32(message.progressPct);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcUpdaterStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcUpdaterStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.progressPct = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcUpdaterStateChanged {
    return {
      state: isSet(object.state) ? updaterStateFromJSON(object.state) : 0,
      progressPct: isSet(object.progressPct) ? globalThis.Number(object.progressPct) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: IpcUpdaterStateChanged): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = updaterStateToJSON(message.state);
    }
    if (message.progressPct !== 0) {
      obj.progressPct = Math.round(message.progressPct);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcUpdaterStateChanged>, I>>(base?: I): IpcUpdaterStateChanged {
    return IpcUpdaterStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcUpdaterStateChanged>, I>>(object: I): IpcUpdaterStateChanged {
    const message = createBaseIpcUpdaterStateChanged();
    message.state = object.state ?? 0;
    message.progressPct = object.progressPct ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseIpcUpdateCheckSuccess(): IpcUpdateCheckSuccess {
  return { isNewer: false, latestVersion: "", changelog: "", downloadUrl: "", signatureUrl: "" };
}

export const IpcUpdateCheckSuccess: MessageFns<IpcUpdateCheckSuccess> = {
  encode(message: IpcUpdateCheckSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isNewer !== false) {
      writer.uint32(8).bool(message.isNewer);
    }
    if (message.latestVersion !== "") {
      writer.uint32(18).string(message.latestVersion);
    }
    if (message.changelog !== "") {
      writer.uint32(26).string(message.changelog);
    }
    if (message.downloadUrl !== "") {
      writer.uint32(34).string(message.downloadUrl);
    }
    if (message.signatureUrl !== "") {
      writer.uint32(42).string(message.signatureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcUpdateCheckSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcUpdateCheckSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isNewer = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.latestVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.changelog = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.downloadUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signatureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcUpdateCheckSuccess {
    return {
      isNewer: isSet(object.isNewer) ? globalThis.Boolean(object.isNewer) : false,
      latestVersion: isSet(object.latestVersion) ? globalThis.String(object.latestVersion) : "",
      changelog: isSet(object.changelog) ? globalThis.String(object.changelog) : "",
      downloadUrl: isSet(object.downloadUrl) ? globalThis.String(object.downloadUrl) : "",
      signatureUrl: isSet(object.signatureUrl) ? globalThis.String(object.signatureUrl) : "",
    };
  },

  toJSON(message: IpcUpdateCheckSuccess): unknown {
    const obj: any = {};
    if (message.isNewer !== false) {
      obj.isNewer = message.isNewer;
    }
    if (message.latestVersion !== "") {
      obj.latestVersion = message.latestVersion;
    }
    if (message.changelog !== "") {
      obj.changelog = message.changelog;
    }
    if (message.downloadUrl !== "") {
      obj.downloadUrl = message.downloadUrl;
    }
    if (message.signatureUrl !== "") {
      obj.signatureUrl = message.signatureUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcUpdateCheckSuccess>, I>>(base?: I): IpcUpdateCheckSuccess {
    return IpcUpdateCheckSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcUpdateCheckSuccess>, I>>(object: I): IpcUpdateCheckSuccess {
    const message = createBaseIpcUpdateCheckSuccess();
    message.isNewer = object.isNewer ?? false;
    message.latestVersion = object.latestVersion ?? "";
    message.changelog = object.changelog ?? "";
    message.downloadUrl = object.downloadUrl ?? "";
    message.signatureUrl = object.signatureUrl ?? "";
    return message;
  },
};

function createBaseIpcUpdateCheckFailed(): IpcUpdateCheckFailed {
  return {};
}

export const IpcUpdateCheckFailed: MessageFns<IpcUpdateCheckFailed> = {
  encode(_: IpcUpdateCheckFailed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcUpdateCheckFailed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcUpdateCheckFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcUpdateCheckFailed {
    return {};
  },

  toJSON(_: IpcUpdateCheckFailed): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcUpdateCheckFailed>, I>>(base?: I): IpcUpdateCheckFailed {
    return IpcUpdateCheckFailed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcUpdateCheckFailed>, I>>(_: I): IpcUpdateCheckFailed {
    const message = createBaseIpcUpdateCheckFailed();
    return message;
  },
};

function createBaseIpcCurrentValueChanged(): IpcCurrentValueChanged {
  return { value: 0 };
}

export const IpcCurrentValueChanged: MessageFns<IpcCurrentValueChanged> = {
  encode(message: IpcCurrentValueChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcCurrentValueChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcCurrentValueChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcCurrentValueChanged {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: IpcCurrentValueChanged): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcCurrentValueChanged>, I>>(base?: I): IpcCurrentValueChanged {
    return IpcCurrentValueChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcCurrentValueChanged>, I>>(object: I): IpcCurrentValueChanged {
    const message = createBaseIpcCurrentValueChanged();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseIpcMonitoringAllowedChanged(): IpcMonitoringAllowedChanged {
  return { isAllowed: false };
}

export const IpcMonitoringAllowedChanged: MessageFns<IpcMonitoringAllowedChanged> = {
  encode(message: IpcMonitoringAllowedChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isAllowed !== false) {
      writer.uint32(8).bool(message.isAllowed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcMonitoringAllowedChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcMonitoringAllowedChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isAllowed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcMonitoringAllowedChanged {
    return { isAllowed: isSet(object.isAllowed) ? globalThis.Boolean(object.isAllowed) : false };
  },

  toJSON(message: IpcMonitoringAllowedChanged): unknown {
    const obj: any = {};
    if (message.isAllowed !== false) {
      obj.isAllowed = message.isAllowed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcMonitoringAllowedChanged>, I>>(base?: I): IpcMonitoringAllowedChanged {
    return IpcMonitoringAllowedChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcMonitoringAllowedChanged>, I>>(object: I): IpcMonitoringAllowedChanged {
    const message = createBaseIpcMonitoringAllowedChanged();
    message.isAllowed = object.isAllowed ?? false;
    return message;
  },
};

function createBaseIpcRequestPlaySfx(): IpcRequestPlaySfx {
  return { sfx: 0 };
}

export const IpcRequestPlaySfx: MessageFns<IpcRequestPlaySfx> = {
  encode(message: IpcRequestPlaySfx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sfx !== 0) {
      writer.uint32(8).uint64(message.sfx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestPlaySfx {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestPlaySfx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sfx = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestPlaySfx {
    return { sfx: isSet(object.sfx) ? globalThis.Number(object.sfx) : 0 };
  },

  toJSON(message: IpcRequestPlaySfx): unknown {
    const obj: any = {};
    if (message.sfx !== 0) {
      obj.sfx = Math.round(message.sfx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestPlaySfx>, I>>(base?: I): IpcRequestPlaySfx {
    return IpcRequestPlaySfx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestPlaySfx>, I>>(object: I): IpcRequestPlaySfx {
    const message = createBaseIpcRequestPlaySfx();
    message.sfx = object.sfx ?? 0;
    return message;
  },
};

function createBaseIpcClientConfigure(): IpcClientConfigure {
  return { currentValueUpdateRateMs: 0, ipcVersion: 0, ipcTag: "" };
}

export const IpcClientConfigure: MessageFns<IpcClientConfigure> = {
  encode(message: IpcClientConfigure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentValueUpdateRateMs !== 0) {
      writer.uint32(8).uint64(message.currentValueUpdateRateMs);
    }
    if (message.ipcVersion !== 0) {
      writer.uint32(16).uint32(message.ipcVersion);
    }
    if (message.ipcTag !== "") {
      writer.uint32(26).string(message.ipcTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcClientConfigure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcClientConfigure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentValueUpdateRateMs = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ipcVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipcTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcClientConfigure {
    return {
      currentValueUpdateRateMs: isSet(object.currentValueUpdateRateMs)
        ? globalThis.Number(object.currentValueUpdateRateMs)
        : 0,
      ipcVersion: isSet(object.ipcVersion) ? globalThis.Number(object.ipcVersion) : 0,
      ipcTag: isSet(object.ipcTag) ? globalThis.String(object.ipcTag) : "",
    };
  },

  toJSON(message: IpcClientConfigure): unknown {
    const obj: any = {};
    if (message.currentValueUpdateRateMs !== 0) {
      obj.currentValueUpdateRateMs = Math.round(message.currentValueUpdateRateMs);
    }
    if (message.ipcVersion !== 0) {
      obj.ipcVersion = Math.round(message.ipcVersion);
    }
    if (message.ipcTag !== "") {
      obj.ipcTag = message.ipcTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcClientConfigure>, I>>(base?: I): IpcClientConfigure {
    return IpcClientConfigure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcClientConfigure>, I>>(object: I): IpcClientConfigure {
    const message = createBaseIpcClientConfigure();
    message.currentValueUpdateRateMs = object.currentValueUpdateRateMs ?? 0;
    message.ipcVersion = object.ipcVersion ?? 0;
    message.ipcTag = object.ipcTag ?? "";
    return message;
  },
};

function createBaseIpcServerHello(): IpcServerHello {
  return { ipcVersion: 0, appVersion: 0 };
}

export const IpcServerHello: MessageFns<IpcServerHello> = {
  encode(message: IpcServerHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipcVersion !== 0) {
      writer.uint32(8).uint32(message.ipcVersion);
    }
    if (message.appVersion !== 0) {
      writer.uint32(16).uint32(message.appVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcServerHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcServerHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ipcVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.appVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcServerHello {
    return {
      ipcVersion: isSet(object.ipcVersion) ? globalThis.Number(object.ipcVersion) : 0,
      appVersion: isSet(object.appVersion) ? globalThis.Number(object.appVersion) : 0,
    };
  },

  toJSON(message: IpcServerHello): unknown {
    const obj: any = {};
    if (message.ipcVersion !== 0) {
      obj.ipcVersion = Math.round(message.ipcVersion);
    }
    if (message.appVersion !== 0) {
      obj.appVersion = Math.round(message.appVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcServerHello>, I>>(base?: I): IpcServerHello {
    return IpcServerHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcServerHello>, I>>(object: I): IpcServerHello {
    const message = createBaseIpcServerHello();
    message.ipcVersion = object.ipcVersion ?? 0;
    message.appVersion = object.appVersion ?? 0;
    return message;
  },
};

function createBaseIpcGuiDeviceChanged(): IpcGuiDeviceChanged {
  return { deviceNameOrUuid: "" };
}

export const IpcGuiDeviceChanged: MessageFns<IpcGuiDeviceChanged> = {
  encode(message: IpcGuiDeviceChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceNameOrUuid !== "") {
      writer.uint32(10).string(message.deviceNameOrUuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcGuiDeviceChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcGuiDeviceChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceNameOrUuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcGuiDeviceChanged {
    return { deviceNameOrUuid: isSet(object.deviceNameOrUuid) ? globalThis.String(object.deviceNameOrUuid) : "" };
  },

  toJSON(message: IpcGuiDeviceChanged): unknown {
    const obj: any = {};
    if (message.deviceNameOrUuid !== "") {
      obj.deviceNameOrUuid = message.deviceNameOrUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcGuiDeviceChanged>, I>>(base?: I): IpcGuiDeviceChanged {
    return IpcGuiDeviceChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcGuiDeviceChanged>, I>>(object: I): IpcGuiDeviceChanged {
    const message = createBaseIpcGuiDeviceChanged();
    message.deviceNameOrUuid = object.deviceNameOrUuid ?? "";
    return message;
  },
};

function createBaseIpcAppEnabledStateChanged(): IpcAppEnabledStateChanged {
  return { state: 0 };
}

export const IpcAppEnabledStateChanged: MessageFns<IpcAppEnabledStateChanged> = {
  encode(message: IpcAppEnabledStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcAppEnabledStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcAppEnabledStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcAppEnabledStateChanged {
    return { state: isSet(object.state) ? appEnabledStateFromJSON(object.state) : 0 };
  },

  toJSON(message: IpcAppEnabledStateChanged): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = appEnabledStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcAppEnabledStateChanged>, I>>(base?: I): IpcAppEnabledStateChanged {
    return IpcAppEnabledStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcAppEnabledStateChanged>, I>>(object: I): IpcAppEnabledStateChanged {
    const message = createBaseIpcAppEnabledStateChanged();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseIpcRequestSwapActivationMode(): IpcRequestSwapActivationMode {
  return { modes: [] };
}

export const IpcRequestSwapActivationMode: MessageFns<IpcRequestSwapActivationMode> = {
  encode(message: IpcRequestSwapActivationMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.modes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSwapActivationMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSwapActivationMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.modes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.modes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSwapActivationMode {
    return {
      modes: globalThis.Array.isArray(object?.modes) ? object.modes.map((e: any) => activationModeFromJSON(e)) : [],
    };
  },

  toJSON(message: IpcRequestSwapActivationMode): unknown {
    const obj: any = {};
    if (message.modes?.length) {
      obj.modes = message.modes.map((e) => activationModeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSwapActivationMode>, I>>(base?: I): IpcRequestSwapActivationMode {
    return IpcRequestSwapActivationMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSwapActivationMode>, I>>(object: I): IpcRequestSwapActivationMode {
    const message = createBaseIpcRequestSwapActivationMode();
    message.modes = object.modes?.map((e) => e) || [];
    return message;
  },
};

function createBaseIpcRequestSetPushToTalkState(): IpcRequestSetPushToTalkState {
  return { keyGroupIndex: 0, isDown: false };
}

export const IpcRequestSetPushToTalkState: MessageFns<IpcRequestSetPushToTalkState> = {
  encode(message: IpcRequestSetPushToTalkState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyGroupIndex !== 0) {
      writer.uint32(8).uint32(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      writer.uint32(16).bool(message.isDown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSetPushToTalkState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSetPushToTalkState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyGroupIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isDown = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSetPushToTalkState {
    return {
      keyGroupIndex: isSet(object.keyGroupIndex) ? globalThis.Number(object.keyGroupIndex) : 0,
      isDown: isSet(object.isDown) ? globalThis.Boolean(object.isDown) : false,
    };
  },

  toJSON(message: IpcRequestSetPushToTalkState): unknown {
    const obj: any = {};
    if (message.keyGroupIndex !== 0) {
      obj.keyGroupIndex = Math.round(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      obj.isDown = message.isDown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSetPushToTalkState>, I>>(base?: I): IpcRequestSetPushToTalkState {
    return IpcRequestSetPushToTalkState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSetPushToTalkState>, I>>(object: I): IpcRequestSetPushToTalkState {
    const message = createBaseIpcRequestSetPushToTalkState();
    message.keyGroupIndex = object.keyGroupIndex ?? 0;
    message.isDown = object.isDown ?? false;
    return message;
  },
};

function createBaseIpcRequestSetPushToMuteState(): IpcRequestSetPushToMuteState {
  return { keyGroupIndex: 0, isDown: false };
}

export const IpcRequestSetPushToMuteState: MessageFns<IpcRequestSetPushToMuteState> = {
  encode(message: IpcRequestSetPushToMuteState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyGroupIndex !== 0) {
      writer.uint32(8).uint32(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      writer.uint32(16).bool(message.isDown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSetPushToMuteState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSetPushToMuteState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyGroupIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isDown = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSetPushToMuteState {
    return {
      keyGroupIndex: isSet(object.keyGroupIndex) ? globalThis.Number(object.keyGroupIndex) : 0,
      isDown: isSet(object.isDown) ? globalThis.Boolean(object.isDown) : false,
    };
  },

  toJSON(message: IpcRequestSetPushToMuteState): unknown {
    const obj: any = {};
    if (message.keyGroupIndex !== 0) {
      obj.keyGroupIndex = Math.round(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      obj.isDown = message.isDown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSetPushToMuteState>, I>>(base?: I): IpcRequestSetPushToMuteState {
    return IpcRequestSetPushToMuteState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSetPushToMuteState>, I>>(object: I): IpcRequestSetPushToMuteState {
    const message = createBaseIpcRequestSetPushToMuteState();
    message.keyGroupIndex = object.keyGroupIndex ?? 0;
    message.isDown = object.isDown ?? false;
    return message;
  },
};

function createBaseIpcRequestSetPushToMuteGlobalState(): IpcRequestSetPushToMuteGlobalState {
  return { isDown: false };
}

export const IpcRequestSetPushToMuteGlobalState: MessageFns<IpcRequestSetPushToMuteGlobalState> = {
  encode(message: IpcRequestSetPushToMuteGlobalState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isDown !== false) {
      writer.uint32(8).bool(message.isDown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSetPushToMuteGlobalState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSetPushToMuteGlobalState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isDown = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSetPushToMuteGlobalState {
    return { isDown: isSet(object.isDown) ? globalThis.Boolean(object.isDown) : false };
  },

  toJSON(message: IpcRequestSetPushToMuteGlobalState): unknown {
    const obj: any = {};
    if (message.isDown !== false) {
      obj.isDown = message.isDown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSetPushToMuteGlobalState>, I>>(
    base?: I,
  ): IpcRequestSetPushToMuteGlobalState {
    return IpcRequestSetPushToMuteGlobalState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSetPushToMuteGlobalState>, I>>(
    object: I,
  ): IpcRequestSetPushToMuteGlobalState {
    const message = createBaseIpcRequestSetPushToMuteGlobalState();
    message.isDown = object.isDown ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
