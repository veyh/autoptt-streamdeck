// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.2
// source: src/autoptt.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "autoptt";

export enum ActivationMode {
  AUTOMATIC = 0,
  TAP_PTT = 1,
  MANUAL = 2,
  TAP_OPEN_MIC_TO_PTT = 3,
  MANUAL_OPEN_MIC_TO_PTT = 4,
  UNRECOGNIZED = -1,
}

export function activationModeFromJSON(object: any): ActivationMode {
  switch (object) {
    case 0:
    case "AUTOMATIC":
      return ActivationMode.AUTOMATIC;
    case 1:
    case "TAP_PTT":
      return ActivationMode.TAP_PTT;
    case 2:
    case "MANUAL":
      return ActivationMode.MANUAL;
    case 3:
    case "TAP_OPEN_MIC_TO_PTT":
      return ActivationMode.TAP_OPEN_MIC_TO_PTT;
    case 4:
    case "MANUAL_OPEN_MIC_TO_PTT":
      return ActivationMode.MANUAL_OPEN_MIC_TO_PTT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActivationMode.UNRECOGNIZED;
  }
}

export function activationModeToJSON(object: ActivationMode): string {
  switch (object) {
    case ActivationMode.AUTOMATIC:
      return "AUTOMATIC";
    case ActivationMode.TAP_PTT:
      return "TAP_PTT";
    case ActivationMode.MANUAL:
      return "MANUAL";
    case ActivationMode.TAP_OPEN_MIC_TO_PTT:
      return "TAP_OPEN_MIC_TO_PTT";
    case ActivationMode.MANUAL_OPEN_MIC_TO_PTT:
      return "MANUAL_OPEN_MIC_TO_PTT";
    case ActivationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MeterType {
  PEAK_VALUE_API = 0,
  CAPTURE_API = 1,
  UNRECOGNIZED = -1,
}

export function meterTypeFromJSON(object: any): MeterType {
  switch (object) {
    case 0:
    case "PEAK_VALUE_API":
      return MeterType.PEAK_VALUE_API;
    case 1:
    case "CAPTURE_API":
      return MeterType.CAPTURE_API;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MeterType.UNRECOGNIZED;
  }
}

export function meterTypeToJSON(object: MeterType): string {
  switch (object) {
    case MeterType.PEAK_VALUE_API:
      return "PEAK_VALUE_API";
    case MeterType.CAPTURE_API:
      return "CAPTURE_API";
    case MeterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StartOnBootType {
  NO = 0,
  YES = 1,
  YES_MINIMIZED = 2,
  UNRECOGNIZED = -1,
}

export function startOnBootTypeFromJSON(object: any): StartOnBootType {
  switch (object) {
    case 0:
    case "NO":
      return StartOnBootType.NO;
    case 1:
    case "YES":
      return StartOnBootType.YES;
    case 2:
    case "YES_MINIMIZED":
      return StartOnBootType.YES_MINIMIZED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StartOnBootType.UNRECOGNIZED;
  }
}

export function startOnBootTypeToJSON(object: StartOnBootType): string {
  switch (object) {
    case StartOnBootType.NO:
      return "NO";
    case StartOnBootType.YES:
      return "YES";
    case StartOnBootType.YES_MINIMIZED:
      return "YES_MINIMIZED";
    case StartOnBootType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** These match the return values from SDL_GetJoystickHat. */
export enum JoyPovDirection {
  CENTERED = 0,
  UP = 1,
  RIGHT = 2,
  DOWN = 4,
  LEFT = 8,
  /** RIGHT_UP - RIGHT | UP */
  RIGHT_UP = 3,
  /** RIGHT_DOWN - RIGHT | DOWN */
  RIGHT_DOWN = 6,
  /** LEFT_UP - LEFT  | UP */
  LEFT_UP = 9,
  /** LEFT_DOWN - LEFT  | DOWN */
  LEFT_DOWN = 12,
  UNRECOGNIZED = -1,
}

export function joyPovDirectionFromJSON(object: any): JoyPovDirection {
  switch (object) {
    case 0:
    case "CENTERED":
      return JoyPovDirection.CENTERED;
    case 1:
    case "UP":
      return JoyPovDirection.UP;
    case 2:
    case "RIGHT":
      return JoyPovDirection.RIGHT;
    case 4:
    case "DOWN":
      return JoyPovDirection.DOWN;
    case 8:
    case "LEFT":
      return JoyPovDirection.LEFT;
    case 3:
    case "RIGHT_UP":
      return JoyPovDirection.RIGHT_UP;
    case 6:
    case "RIGHT_DOWN":
      return JoyPovDirection.RIGHT_DOWN;
    case 9:
    case "LEFT_UP":
      return JoyPovDirection.LEFT_UP;
    case 12:
    case "LEFT_DOWN":
      return JoyPovDirection.LEFT_DOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JoyPovDirection.UNRECOGNIZED;
  }
}

export function joyPovDirectionToJSON(object: JoyPovDirection): string {
  switch (object) {
    case JoyPovDirection.CENTERED:
      return "CENTERED";
    case JoyPovDirection.UP:
      return "UP";
    case JoyPovDirection.RIGHT:
      return "RIGHT";
    case JoyPovDirection.DOWN:
      return "DOWN";
    case JoyPovDirection.LEFT:
      return "LEFT";
    case JoyPovDirection.RIGHT_UP:
      return "RIGHT_UP";
    case JoyPovDirection.RIGHT_DOWN:
      return "RIGHT_DOWN";
    case JoyPovDirection.LEFT_UP:
      return "LEFT_UP";
    case JoyPovDirection.LEFT_DOWN:
      return "LEFT_DOWN";
    case JoyPovDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ActivityState {
  INACTIVE = 0,
  ACTIVE = 1,
  ACTIVE_RELEASE_DELAY = 2,
  ACTIVE_TAP_ACTIVATION_WINDOW = 3,
  UNRECOGNIZED = -1,
}

export function activityStateFromJSON(object: any): ActivityState {
  switch (object) {
    case 0:
    case "INACTIVE":
      return ActivityState.INACTIVE;
    case 1:
    case "ACTIVE":
      return ActivityState.ACTIVE;
    case 2:
    case "ACTIVE_RELEASE_DELAY":
      return ActivityState.ACTIVE_RELEASE_DELAY;
    case 3:
    case "ACTIVE_TAP_ACTIVATION_WINDOW":
      return ActivityState.ACTIVE_TAP_ACTIVATION_WINDOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActivityState.UNRECOGNIZED;
  }
}

export function activityStateToJSON(object: ActivityState): string {
  switch (object) {
    case ActivityState.INACTIVE:
      return "INACTIVE";
    case ActivityState.ACTIVE:
      return "ACTIVE";
    case ActivityState.ACTIVE_RELEASE_DELAY:
      return "ACTIVE_RELEASE_DELAY";
    case ActivityState.ACTIVE_TAP_ACTIVATION_WINDOW:
      return "ACTIVE_TAP_ACTIVATION_WINDOW";
    case ActivityState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum UpdaterState {
  IDLE = 0,
  UPDATING = 1,
  UPDATE_FAILED = 2,
  UPDATE_SUCCESS = 3,
  UNRECOGNIZED = -1,
}

export function updaterStateFromJSON(object: any): UpdaterState {
  switch (object) {
    case 0:
    case "IDLE":
      return UpdaterState.IDLE;
    case 1:
    case "UPDATING":
      return UpdaterState.UPDATING;
    case 2:
    case "UPDATE_FAILED":
      return UpdaterState.UPDATE_FAILED;
    case 3:
    case "UPDATE_SUCCESS":
      return UpdaterState.UPDATE_SUCCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UpdaterState.UNRECOGNIZED;
  }
}

export function updaterStateToJSON(object: UpdaterState): string {
  switch (object) {
    case UpdaterState.IDLE:
      return "IDLE";
    case UpdaterState.UPDATING:
      return "UPDATING";
    case UpdaterState.UPDATE_FAILED:
      return "UPDATE_FAILED";
    case UpdaterState.UPDATE_SUCCESS:
      return "UPDATE_SUCCESS";
    case UpdaterState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AppEnabledState {
  ENABLED = 0,
  /** DISABLED_INVALID_LICENSE - Occures when the license is either invalid or the trial has expired. */
  DISABLED_INVALID_LICENSE = 1,
  /**
   * DISABLED_BLOCKED_BY_GUI - Occurs when the app is temporarily disabled due to editing the settings,
   * such as when you're writing into a text box, binding a key, or changing
   * a sound effect.
   */
  DISABLED_BLOCKED_BY_GUI = 2,
  UNRECOGNIZED = -1,
}

export function appEnabledStateFromJSON(object: any): AppEnabledState {
  switch (object) {
    case 0:
    case "ENABLED":
      return AppEnabledState.ENABLED;
    case 1:
    case "DISABLED_INVALID_LICENSE":
      return AppEnabledState.DISABLED_INVALID_LICENSE;
    case 2:
    case "DISABLED_BLOCKED_BY_GUI":
      return AppEnabledState.DISABLED_BLOCKED_BY_GUI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AppEnabledState.UNRECOGNIZED;
  }
}

export function appEnabledStateToJSON(object: AppEnabledState): string {
  switch (object) {
    case AppEnabledState.ENABLED:
      return "ENABLED";
    case AppEnabledState.DISABLED_INVALID_LICENSE:
      return "DISABLED_INVALID_LICENSE";
    case AppEnabledState.DISABLED_BLOCKED_BY_GUI:
      return "DISABLED_BLOCKED_BY_GUI";
    case AppEnabledState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Settings {
  version: number;
  appVersion: number;
  selectedTab: SelectedTab | undefined;
  startOnBootType: StartOnBootType;
  licenseKey: string;
  ipcAddr: string;
  minimizeToTray: boolean;
  updateCheck: boolean;
  useSidekick: boolean;
  autoProfileSwitch: boolean;
  profile: number;
  profiles: Profile[];
  x3xThreshold: number;
  x3xUseDeactThreshold: boolean;
  x3xDeactThreshold: number;
  x3xSafe: boolean;
  x3xSafeIntervalMs: number;
  x3xDeprecatedUpdateIntervalMs: number;
  x3xReleaseDelayMs: number;
  x3xActivationMode: ActivationMode;
  x3xMeterType: MeterType;
  /** --> device_name, device_uuid (v6) */
  x3xDeprecatedDeviceNameOrUuid: string;
  x3xSoundOnPttDown: Sound | undefined;
  x3xSoundOnPttUp: Sound | undefined;
  x3xSoundOnPushToMuteDown: Sound | undefined;
  x3xSoundOnPushToMuteUp: Sound | undefined;
  x3xSoundOnPushToMuteGlobalDown: Sound | undefined;
  x3xSoundOnPushToMuteGlobalUp: Sound | undefined;
  x3xSoundOnSetModeToVoiceActivity: Sound | undefined;
  x3xSoundOnSetModeToTap: Sound | undefined;
  x3xSoundOnSetModeToManual: Sound | undefined;
  x3xSoundOnSetModeToTapOpenMicToPtt: Sound | undefined;
  x3xSoundOnSetModeToManualOpenMicToPtt: Sound | undefined;
  x3xSoundOnToggleMuteGlobalOn: Sound | undefined;
  x3xSoundOnToggleMuteGlobalOff: Sound | undefined;
  x3xSoundOnToggleMuteOn: Sound | undefined;
  x3xSoundOnToggleMuteOff:
    | Sound
    | undefined;
  /** --> key_groups (v4) */
  x3xPttSingle:
    | HotkeyV3
    | undefined;
  /** --> key_groups (v4) */
  x3xKeyPushToMuteSingle: HotkeyV3 | undefined;
  x3xKeyPushToMuteGlobal: HotkeyV3 | undefined;
  x3xKeySetModeToVoiceActivity: HotkeyV3 | undefined;
  x3xKeySetModeToTap: HotkeyV3 | undefined;
  x3xKeySetModeToManual: HotkeyV3 | undefined;
  x3xKeySetModeToTapOpenMicToPtt: HotkeyV3 | undefined;
  x3xKeySetModeToManualOpenMicToPtt: HotkeyV3 | undefined;
  x3xKeySwapModeBetweenManualAndVoiceActivity: HotkeyV3 | undefined;
  x3xKeySwapModeBetweenManualAndTap: HotkeyV3 | undefined;
  x3xKeySwapModeBetweenManualAndManualOpenMicToPtt: HotkeyV3 | undefined;
  x3xKeyToggleMuteGlobal:
    | HotkeyV3
    | undefined;
  /** --> key_groups (v4) */
  x3xDeprecatedExtraTriggerKeys: HotkeyV3[];
  x3xOpenMicToPttConsumeInput: boolean;
  x3xOverlayEnable: boolean;
  x3xOverlaySettings: OverlaySettings | undefined;
  x3xDeviceDisplayName: string;
  x3xKeyGroups: HotkeyGroup[];
  x3xUseTapActivationWindow: boolean;
  x3xTapActivationWindowMs: number;
  x3xDeviceName: string;
  x3xDeviceUuid: string;
}

export interface Profile {
  id: Uint8Array;
  name: string;
  /** These are matched with OR */
  activationTriggers: ProfileActivationTrigger[];
  settings: ProfileSettings | undefined;
}

export interface ProfileSettings {
  threshold: number;
  useDeactThreshold: boolean;
  deactThreshold: number;
  safe: boolean;
  safeIntervalMs: number;
  releaseDelayMs: number;
  activationMode: ActivationMode;
  meterType: MeterType;
  soundOnPttDown: Sound | undefined;
  soundOnPttUp: Sound | undefined;
  soundOnPushToMuteDown: Sound | undefined;
  soundOnPushToMuteUp: Sound | undefined;
  soundOnPushToMuteGlobalDown: Sound | undefined;
  soundOnPushToMuteGlobalUp: Sound | undefined;
  soundOnSetModeToVoiceActivity: Sound | undefined;
  soundOnSetModeToTap: Sound | undefined;
  soundOnSetModeToManual: Sound | undefined;
  soundOnSetModeToTapOpenMicToPtt: Sound | undefined;
  soundOnSetModeToManualOpenMicToPtt: Sound | undefined;
  soundOnToggleMuteGlobalOn: Sound | undefined;
  soundOnToggleMuteGlobalOff: Sound | undefined;
  soundOnToggleMuteOn: Sound | undefined;
  soundOnToggleMuteOff: Sound | undefined;
  keyPushToMuteGlobal: HotkeyV3 | undefined;
  keySetModeToVoiceActivity: HotkeyV3 | undefined;
  keySetModeToTap: HotkeyV3 | undefined;
  keySetModeToManual: HotkeyV3 | undefined;
  keySetModeToTapOpenMicToPtt: HotkeyV3 | undefined;
  keySetModeToManualOpenMicToPtt: HotkeyV3 | undefined;
  keySwapModeBetweenManualAndVoiceActivity: HotkeyV3 | undefined;
  keySwapModeBetweenManualAndTap: HotkeyV3 | undefined;
  keySwapModeBetweenManualAndManualOpenMicToPtt: HotkeyV3 | undefined;
  keyToggleMuteGlobal: HotkeyV3 | undefined;
  openMicToPttConsumeInput: boolean;
  overlayEnable: boolean;
  overlaySettings: OverlaySettings | undefined;
  deviceDisplayName: string;
  keyGroups: HotkeyGroup[];
  useTapActivationWindow: boolean;
  tapActivationWindowMs: number;
  deviceName: string;
  deviceUuid: string;
}

export interface ProfileActivationTrigger {
  type: ProfileActivationTrigger_TextType;
  text: string;
  activeWindowOnly: boolean;
}

export enum ProfileActivationTrigger_TextType {
  BINARY_NAME = 0,
  BINARY_PATH = 1,
  WINDOW_TITLE = 2,
  UNRECOGNIZED = -1,
}

export function profileActivationTrigger_TextTypeFromJSON(object: any): ProfileActivationTrigger_TextType {
  switch (object) {
    case 0:
    case "BINARY_NAME":
      return ProfileActivationTrigger_TextType.BINARY_NAME;
    case 1:
    case "BINARY_PATH":
      return ProfileActivationTrigger_TextType.BINARY_PATH;
    case 2:
    case "WINDOW_TITLE":
      return ProfileActivationTrigger_TextType.WINDOW_TITLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProfileActivationTrigger_TextType.UNRECOGNIZED;
  }
}

export function profileActivationTrigger_TextTypeToJSON(object: ProfileActivationTrigger_TextType): string {
  switch (object) {
    case ProfileActivationTrigger_TextType.BINARY_NAME:
      return "BINARY_NAME";
    case ProfileActivationTrigger_TextType.BINARY_PATH:
      return "BINARY_PATH";
    case ProfileActivationTrigger_TextType.WINDOW_TITLE:
      return "WINDOW_TITLE";
    case ProfileActivationTrigger_TextType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Sound {
  enabled: boolean;
  file: string;
  volume: number;
}

export interface HotkeyV3 {
  vkCodes: number[];
  joyButtons: JoyButton[];
  joyPovs: JoyPov[];
}

export interface JoyButton {
  joyId: JoyId | undefined;
  button: number;
}

export interface JoyPov {
  joyId: JoyId | undefined;
  index: number;
  direction: JoyPovDirection;
}

export interface JoyId {
  /** Used to identify the device, so must be provided. */
  guid: Uint8Array;
  /** Used to show a human readable name only, so technically optional. */
  name: string;
}

export interface HotkeyGroup {
  displayName: string;
  pushToTalk: HotkeyV3 | undefined;
  pushToMute: HotkeyV3[];
  extraTriggers: HotkeyV3[];
  toggleMute: HotkeyV3[];
}

export interface SelectedTab {
  settingsGeneral?: SelectedTabSettingsGeneral | undefined;
  settingsDevice?: SelectedTabSettingsDevice | undefined;
  overview?: SelectedTabOverview | undefined;
}

export interface SelectedTabOverview {
}

export interface SelectedTabSettingsGeneral {
}

export interface SelectedTabSettingsDevice {
  deviceIndex: number;
}

export interface Ipc {
  serverHello?: IpcServerHello | undefined;
  activityStateChanged?: IpcActivityStateChanged | undefined;
  appEnabledStateChanged?: IpcAppEnabledStateChanged | undefined;
  currentValueChanged?: IpcCurrentValueChanged | undefined;
  muteStateChanged?: IpcMuteStateChanged | undefined;
  settingsChanged?: IpcSettingsChanged | undefined;
  toggleMuteGlobalChanged?: IpcToggleMuteGlobalChanged | undefined;
  toggleMuteChanged?: IpcToggleMuteChanged | undefined;
  sidekickConnected?: IpcSidekickConnected | undefined;
  sidekickDisconnected?: IpcSidekickDisconnected | undefined;
  updaterStateChanged?: IpcUpdaterStateChanged | undefined;
  updateCheckSuccess?: IpcUpdateCheckSuccess | undefined;
  updateCheckFailed?: IpcUpdateCheckFailed | undefined;
  guiDeviceChanged?: IpcGuiDeviceChanged | undefined;
  overlayHello?: IpcOverlayHello | undefined;
  clientConfigure?: IpcClientConfigure | undefined;
  requestRestart?: IpcRequestRestart | undefined;
  requestExit?: IpcRequestExit | undefined;
  requestUpdate?: IpcRequestUpdate | undefined;
  requestUpdateSettings?: IpcRequestUpdateSettings | undefined;
  requestPlaySfx?: IpcRequestPlaySfx | undefined;
  requestSwapActivationMode?: IpcRequestSwapActivationMode | undefined;
  requestSetPushToTalkState?: IpcRequestSetPushToTalkState | undefined;
  requestSetPushToMuteState?: IpcRequestSetPushToMuteState | undefined;
  requestSetPushToMuteGlobalState?: IpcRequestSetPushToMuteGlobalState | undefined;
  requestToggleMuteGlobal?: IpcRequestToggleMuteGlobal | undefined;
  requestToggleMute?: IpcRequestToggleMute | undefined;
}

export interface IpcActivityStateChanged {
  aggregateState: ActivityState;
  keyGroupStates: ActivityState[];
}

export interface IpcMuteStateChanged {
  isMuted: boolean;
}

export interface IpcSettingsChanged {
  settings: Settings | undefined;
}

export interface OverlaySettings {
  showWhenInactive: boolean;
  showModeText: boolean;
  showPttKeyName: boolean;
  isMovable: boolean;
  x: number;
  y: number;
}

export interface IpcOverlayHello {
}

export interface IpcSidekickConnected {
  port: string;
}

export interface IpcSidekickDisconnected {
}

export interface IpcRequestRestart {
}

export interface IpcRequestExit {
}

export interface IpcRequestUpdate {
}

export interface IpcRequestUpdateSettings {
  settings: Settings | undefined;
  forceLicenseCheck: boolean;
}

export interface IpcUpdaterStateChanged {
  state: UpdaterState;
  progressPct: number;
  message: string;
}

export interface IpcUpdateCheckSuccess {
  isNewer: boolean;
  latestVersion: string;
  changelog: string;
  downloadUrl: string;
  signatureUrl: string;
}

export interface IpcUpdateCheckFailed {
}

export interface IpcCurrentValueChanged {
  value: number;
}

export interface IpcMonitoringAllowedChanged {
  isAllowed: boolean;
}

export interface IpcToggleMuteGlobalChanged {
  isActive: boolean;
}

export interface IpcToggleMuteChanged {
  keyGroupIndex: number;
  isActive: boolean;
}

export interface IpcRequestPlaySfx {
  sfx: number;
}

export interface IpcClientConfigure {
  /** Defaults to 0 (disabled). */
  currentValueUpdateRateMs: number;
  ipcVersion: number;
  ipcTag: string;
}

export interface IpcServerHello {
  /** SHOULD BE EQUAL TO CLIENT, otherwise no promises anything will work! */
  ipcVersion: number;
  /**
   * Format:  (major * 1000 * 1000) + (minor * 1000) + patch
   * Example: app version 1.2.3 --> 1002003
   */
  appVersion: number;
}

export interface IpcGuiDeviceChanged {
  deviceNameOrUuid: string;
}

export interface IpcAppEnabledStateChanged {
  state: AppEnabledState;
}

export interface IpcRequestSwapActivationMode {
  modes: ActivationMode[];
}

export interface IpcRequestSetPushToTalkState {
  keyGroupIndex: number;
  isDown: boolean;
}

export interface IpcRequestSetPushToMuteState {
  keyGroupIndex: number;
  isDown: boolean;
}

export interface IpcRequestSetPushToMuteGlobalState {
  isDown: boolean;
}

export interface IpcRequestToggleMuteGlobal {
}

export interface IpcRequestToggleMute {
  keyGroupIndex: number;
}

function createBaseSettings(): Settings {
  return {
    version: 0,
    appVersion: 0,
    selectedTab: undefined,
    startOnBootType: 0,
    licenseKey: "",
    ipcAddr: "",
    minimizeToTray: false,
    updateCheck: false,
    useSidekick: false,
    autoProfileSwitch: false,
    profile: 0,
    profiles: [],
    x3xThreshold: 0,
    x3xUseDeactThreshold: false,
    x3xDeactThreshold: 0,
    x3xSafe: false,
    x3xSafeIntervalMs: 0,
    x3xDeprecatedUpdateIntervalMs: 0,
    x3xReleaseDelayMs: 0,
    x3xActivationMode: 0,
    x3xMeterType: 0,
    x3xDeprecatedDeviceNameOrUuid: "",
    x3xSoundOnPttDown: undefined,
    x3xSoundOnPttUp: undefined,
    x3xSoundOnPushToMuteDown: undefined,
    x3xSoundOnPushToMuteUp: undefined,
    x3xSoundOnPushToMuteGlobalDown: undefined,
    x3xSoundOnPushToMuteGlobalUp: undefined,
    x3xSoundOnSetModeToVoiceActivity: undefined,
    x3xSoundOnSetModeToTap: undefined,
    x3xSoundOnSetModeToManual: undefined,
    x3xSoundOnSetModeToTapOpenMicToPtt: undefined,
    x3xSoundOnSetModeToManualOpenMicToPtt: undefined,
    x3xSoundOnToggleMuteGlobalOn: undefined,
    x3xSoundOnToggleMuteGlobalOff: undefined,
    x3xSoundOnToggleMuteOn: undefined,
    x3xSoundOnToggleMuteOff: undefined,
    x3xPttSingle: undefined,
    x3xKeyPushToMuteSingle: undefined,
    x3xKeyPushToMuteGlobal: undefined,
    x3xKeySetModeToVoiceActivity: undefined,
    x3xKeySetModeToTap: undefined,
    x3xKeySetModeToManual: undefined,
    x3xKeySetModeToTapOpenMicToPtt: undefined,
    x3xKeySetModeToManualOpenMicToPtt: undefined,
    x3xKeySwapModeBetweenManualAndVoiceActivity: undefined,
    x3xKeySwapModeBetweenManualAndTap: undefined,
    x3xKeySwapModeBetweenManualAndManualOpenMicToPtt: undefined,
    x3xKeyToggleMuteGlobal: undefined,
    x3xDeprecatedExtraTriggerKeys: [],
    x3xOpenMicToPttConsumeInput: false,
    x3xOverlayEnable: false,
    x3xOverlaySettings: undefined,
    x3xDeviceDisplayName: "",
    x3xKeyGroups: [],
    x3xUseTapActivationWindow: false,
    x3xTapActivationWindowMs: 0,
    x3xDeviceName: "",
    x3xDeviceUuid: "",
  };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.appVersion !== 0) {
      writer.uint32(464).uint64(message.appVersion);
    }
    if (message.selectedTab !== undefined) {
      SelectedTab.encode(message.selectedTab, writer.uint32(410).fork()).join();
    }
    if (message.startOnBootType !== 0) {
      writer.uint32(104).int32(message.startOnBootType);
    }
    if (message.licenseKey !== "") {
      writer.uint32(122).string(message.licenseKey);
    }
    if (message.ipcAddr !== "") {
      writer.uint32(338).string(message.ipcAddr);
    }
    if (message.minimizeToTray !== false) {
      writer.uint32(312).bool(message.minimizeToTray);
    }
    if (message.updateCheck !== false) {
      writer.uint32(328).bool(message.updateCheck);
    }
    if (message.useSidekick !== false) {
      writer.uint32(128).bool(message.useSidekick);
    }
    if (message.autoProfileSwitch !== false) {
      writer.uint32(472).bool(message.autoProfileSwitch);
    }
    if (message.profile !== 0) {
      writer.uint32(520).uint64(message.profile);
    }
    for (const v of message.profiles) {
      Profile.encode(v!, writer.uint32(530).fork()).join();
    }
    if (message.x3xThreshold !== 0) {
      writer.uint32(17).double(message.x3xThreshold);
    }
    if (message.x3xUseDeactThreshold !== false) {
      writer.uint32(24).bool(message.x3xUseDeactThreshold);
    }
    if (message.x3xDeactThreshold !== 0) {
      writer.uint32(33).double(message.x3xDeactThreshold);
    }
    if (message.x3xSafe !== false) {
      writer.uint32(40).bool(message.x3xSafe);
    }
    if (message.x3xSafeIntervalMs !== 0) {
      writer.uint32(48).uint32(message.x3xSafeIntervalMs);
    }
    if (message.x3xDeprecatedUpdateIntervalMs !== 0) {
      writer.uint32(56).uint32(message.x3xDeprecatedUpdateIntervalMs);
    }
    if (message.x3xReleaseDelayMs !== 0) {
      writer.uint32(64).uint32(message.x3xReleaseDelayMs);
    }
    if (message.x3xActivationMode !== 0) {
      writer.uint32(88).int32(message.x3xActivationMode);
    }
    if (message.x3xMeterType !== 0) {
      writer.uint32(96).int32(message.x3xMeterType);
    }
    if (message.x3xDeprecatedDeviceNameOrUuid !== "") {
      writer.uint32(114).string(message.x3xDeprecatedDeviceNameOrUuid);
    }
    if (message.x3xSoundOnPttDown !== undefined) {
      Sound.encode(message.x3xSoundOnPttDown, writer.uint32(138).fork()).join();
    }
    if (message.x3xSoundOnPttUp !== undefined) {
      Sound.encode(message.x3xSoundOnPttUp, writer.uint32(146).fork()).join();
    }
    if (message.x3xSoundOnPushToMuteDown !== undefined) {
      Sound.encode(message.x3xSoundOnPushToMuteDown, writer.uint32(154).fork()).join();
    }
    if (message.x3xSoundOnPushToMuteUp !== undefined) {
      Sound.encode(message.x3xSoundOnPushToMuteUp, writer.uint32(162).fork()).join();
    }
    if (message.x3xSoundOnPushToMuteGlobalDown !== undefined) {
      Sound.encode(message.x3xSoundOnPushToMuteGlobalDown, writer.uint32(170).fork()).join();
    }
    if (message.x3xSoundOnPushToMuteGlobalUp !== undefined) {
      Sound.encode(message.x3xSoundOnPushToMuteGlobalUp, writer.uint32(178).fork()).join();
    }
    if (message.x3xSoundOnSetModeToVoiceActivity !== undefined) {
      Sound.encode(message.x3xSoundOnSetModeToVoiceActivity, writer.uint32(186).fork()).join();
    }
    if (message.x3xSoundOnSetModeToTap !== undefined) {
      Sound.encode(message.x3xSoundOnSetModeToTap, writer.uint32(194).fork()).join();
    }
    if (message.x3xSoundOnSetModeToManual !== undefined) {
      Sound.encode(message.x3xSoundOnSetModeToManual, writer.uint32(202).fork()).join();
    }
    if (message.x3xSoundOnSetModeToTapOpenMicToPtt !== undefined) {
      Sound.encode(message.x3xSoundOnSetModeToTapOpenMicToPtt, writer.uint32(210).fork()).join();
    }
    if (message.x3xSoundOnSetModeToManualOpenMicToPtt !== undefined) {
      Sound.encode(message.x3xSoundOnSetModeToManualOpenMicToPtt, writer.uint32(218).fork()).join();
    }
    if (message.x3xSoundOnToggleMuteGlobalOn !== undefined) {
      Sound.encode(message.x3xSoundOnToggleMuteGlobalOn, writer.uint32(490).fork()).join();
    }
    if (message.x3xSoundOnToggleMuteGlobalOff !== undefined) {
      Sound.encode(message.x3xSoundOnToggleMuteGlobalOff, writer.uint32(498).fork()).join();
    }
    if (message.x3xSoundOnToggleMuteOn !== undefined) {
      Sound.encode(message.x3xSoundOnToggleMuteOn, writer.uint32(506).fork()).join();
    }
    if (message.x3xSoundOnToggleMuteOff !== undefined) {
      Sound.encode(message.x3xSoundOnToggleMuteOff, writer.uint32(514).fork()).join();
    }
    if (message.x3xPttSingle !== undefined) {
      HotkeyV3.encode(message.x3xPttSingle, writer.uint32(82).fork()).join();
    }
    if (message.x3xKeyPushToMuteSingle !== undefined) {
      HotkeyV3.encode(message.x3xKeyPushToMuteSingle, writer.uint32(226).fork()).join();
    }
    if (message.x3xKeyPushToMuteGlobal !== undefined) {
      HotkeyV3.encode(message.x3xKeyPushToMuteGlobal, writer.uint32(234).fork()).join();
    }
    if (message.x3xKeySetModeToVoiceActivity !== undefined) {
      HotkeyV3.encode(message.x3xKeySetModeToVoiceActivity, writer.uint32(242).fork()).join();
    }
    if (message.x3xKeySetModeToTap !== undefined) {
      HotkeyV3.encode(message.x3xKeySetModeToTap, writer.uint32(250).fork()).join();
    }
    if (message.x3xKeySetModeToManual !== undefined) {
      HotkeyV3.encode(message.x3xKeySetModeToManual, writer.uint32(258).fork()).join();
    }
    if (message.x3xKeySetModeToTapOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.x3xKeySetModeToTapOpenMicToPtt, writer.uint32(266).fork()).join();
    }
    if (message.x3xKeySetModeToManualOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.x3xKeySetModeToManualOpenMicToPtt, writer.uint32(274).fork()).join();
    }
    if (message.x3xKeySwapModeBetweenManualAndVoiceActivity !== undefined) {
      HotkeyV3.encode(message.x3xKeySwapModeBetweenManualAndVoiceActivity, writer.uint32(282).fork()).join();
    }
    if (message.x3xKeySwapModeBetweenManualAndTap !== undefined) {
      HotkeyV3.encode(message.x3xKeySwapModeBetweenManualAndTap, writer.uint32(290).fork()).join();
    }
    if (message.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt, writer.uint32(298).fork()).join();
    }
    if (message.x3xKeyToggleMuteGlobal !== undefined) {
      HotkeyV3.encode(message.x3xKeyToggleMuteGlobal, writer.uint32(482).fork()).join();
    }
    for (const v of message.x3xDeprecatedExtraTriggerKeys) {
      HotkeyV3.encode(v!, writer.uint32(306).fork()).join();
    }
    if (message.x3xOpenMicToPttConsumeInput !== false) {
      writer.uint32(320).bool(message.x3xOpenMicToPttConsumeInput);
    }
    if (message.x3xOverlayEnable !== false) {
      writer.uint32(344).bool(message.x3xOverlayEnable);
    }
    if (message.x3xOverlaySettings !== undefined) {
      OverlaySettings.encode(message.x3xOverlaySettings, writer.uint32(354).fork()).join();
    }
    if (message.x3xDeviceDisplayName !== "") {
      writer.uint32(362).string(message.x3xDeviceDisplayName);
    }
    for (const v of message.x3xKeyGroups) {
      HotkeyGroup.encode(v!, writer.uint32(402).fork()).join();
    }
    if (message.x3xUseTapActivationWindow !== false) {
      writer.uint32(416).bool(message.x3xUseTapActivationWindow);
    }
    if (message.x3xTapActivationWindowMs !== 0) {
      writer.uint32(424).uint32(message.x3xTapActivationWindowMs);
    }
    if (message.x3xDeviceName !== "") {
      writer.uint32(450).string(message.x3xDeviceName);
    }
    if (message.x3xDeviceUuid !== "") {
      writer.uint32(458).string(message.x3xDeviceUuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 58: {
          if (tag !== 464) {
            break;
          }

          message.appVersion = longToNumber(reader.uint64());
          continue;
        }
        case 51: {
          if (tag !== 410) {
            break;
          }

          message.selectedTab = SelectedTab.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.startOnBootType = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.licenseKey = reader.string();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.ipcAddr = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.minimizeToTray = reader.bool();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.updateCheck = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.useSidekick = reader.bool();
          continue;
        }
        case 59: {
          if (tag !== 472) {
            break;
          }

          message.autoProfileSwitch = reader.bool();
          continue;
        }
        case 65: {
          if (tag !== 520) {
            break;
          }

          message.profile = longToNumber(reader.uint64());
          continue;
        }
        case 66: {
          if (tag !== 530) {
            break;
          }

          message.profiles.push(Profile.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.x3xThreshold = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.x3xUseDeactThreshold = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.x3xDeactThreshold = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.x3xSafe = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.x3xSafeIntervalMs = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.x3xDeprecatedUpdateIntervalMs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.x3xReleaseDelayMs = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.x3xActivationMode = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.x3xMeterType = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.x3xDeprecatedDeviceNameOrUuid = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.x3xSoundOnPttDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.x3xSoundOnPttUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.x3xSoundOnPushToMuteDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.x3xSoundOnPushToMuteUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.x3xSoundOnPushToMuteGlobalDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.x3xSoundOnPushToMuteGlobalUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.x3xSoundOnSetModeToVoiceActivity = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.x3xSoundOnSetModeToTap = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.x3xSoundOnSetModeToManual = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.x3xSoundOnSetModeToTapOpenMicToPtt = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.x3xSoundOnSetModeToManualOpenMicToPtt = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.x3xSoundOnToggleMuteGlobalOn = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 62: {
          if (tag !== 498) {
            break;
          }

          message.x3xSoundOnToggleMuteGlobalOff = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 63: {
          if (tag !== 506) {
            break;
          }

          message.x3xSoundOnToggleMuteOn = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.x3xSoundOnToggleMuteOff = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.x3xPttSingle = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.x3xKeyPushToMuteSingle = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.x3xKeyPushToMuteGlobal = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.x3xKeySetModeToVoiceActivity = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.x3xKeySetModeToTap = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.x3xKeySetModeToManual = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.x3xKeySetModeToTapOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.x3xKeySetModeToManualOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.x3xKeySwapModeBetweenManualAndVoiceActivity = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.x3xKeySwapModeBetweenManualAndTap = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 60: {
          if (tag !== 482) {
            break;
          }

          message.x3xKeyToggleMuteGlobal = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.x3xDeprecatedExtraTriggerKeys.push(HotkeyV3.decode(reader, reader.uint32()));
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.x3xOpenMicToPttConsumeInput = reader.bool();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }

          message.x3xOverlayEnable = reader.bool();
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.x3xOverlaySettings = OverlaySettings.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.x3xDeviceDisplayName = reader.string();
          continue;
        }
        case 50: {
          if (tag !== 402) {
            break;
          }

          message.x3xKeyGroups.push(HotkeyGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.x3xUseTapActivationWindow = reader.bool();
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }

          message.x3xTapActivationWindowMs = reader.uint32();
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.x3xDeviceName = reader.string();
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.x3xDeviceUuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      appVersion: isSet(object.appVersion) ? globalThis.Number(object.appVersion) : 0,
      selectedTab: isSet(object.selectedTab) ? SelectedTab.fromJSON(object.selectedTab) : undefined,
      startOnBootType: isSet(object.startOnBootType) ? startOnBootTypeFromJSON(object.startOnBootType) : 0,
      licenseKey: isSet(object.licenseKey) ? globalThis.String(object.licenseKey) : "",
      ipcAddr: isSet(object.ipcAddr) ? globalThis.String(object.ipcAddr) : "",
      minimizeToTray: isSet(object.minimizeToTray) ? globalThis.Boolean(object.minimizeToTray) : false,
      updateCheck: isSet(object.updateCheck) ? globalThis.Boolean(object.updateCheck) : false,
      useSidekick: isSet(object.useSidekick) ? globalThis.Boolean(object.useSidekick) : false,
      autoProfileSwitch: isSet(object.autoProfileSwitch) ? globalThis.Boolean(object.autoProfileSwitch) : false,
      profile: isSet(object.profile) ? globalThis.Number(object.profile) : 0,
      profiles: globalThis.Array.isArray(object?.profiles) ? object.profiles.map((e: any) => Profile.fromJSON(e)) : [],
      x3xThreshold: isSet(object.x3xThreshold) ? globalThis.Number(object.x3xThreshold) : 0,
      x3xUseDeactThreshold: isSet(object.x3xUseDeactThreshold)
        ? globalThis.Boolean(object.x3xUseDeactThreshold)
        : false,
      x3xDeactThreshold: isSet(object.x3xDeactThreshold) ? globalThis.Number(object.x3xDeactThreshold) : 0,
      x3xSafe: isSet(object.x3xSafe) ? globalThis.Boolean(object.x3xSafe) : false,
      x3xSafeIntervalMs: isSet(object.x3xSafeIntervalMs) ? globalThis.Number(object.x3xSafeIntervalMs) : 0,
      x3xDeprecatedUpdateIntervalMs: isSet(object.x3xDeprecatedUpdateIntervalMs)
        ? globalThis.Number(object.x3xDeprecatedUpdateIntervalMs)
        : 0,
      x3xReleaseDelayMs: isSet(object.x3xReleaseDelayMs) ? globalThis.Number(object.x3xReleaseDelayMs) : 0,
      x3xActivationMode: isSet(object.x3xActivationMode) ? activationModeFromJSON(object.x3xActivationMode) : 0,
      x3xMeterType: isSet(object.x3xMeterType) ? meterTypeFromJSON(object.x3xMeterType) : 0,
      x3xDeprecatedDeviceNameOrUuid: isSet(object.x3xDeprecatedDeviceNameOrUuid)
        ? globalThis.String(object.x3xDeprecatedDeviceNameOrUuid)
        : "",
      x3xSoundOnPttDown: isSet(object.x3xSoundOnPttDown) ? Sound.fromJSON(object.x3xSoundOnPttDown) : undefined,
      x3xSoundOnPttUp: isSet(object.x3xSoundOnPttUp) ? Sound.fromJSON(object.x3xSoundOnPttUp) : undefined,
      x3xSoundOnPushToMuteDown: isSet(object.x3xSoundOnPushToMuteDown)
        ? Sound.fromJSON(object.x3xSoundOnPushToMuteDown)
        : undefined,
      x3xSoundOnPushToMuteUp: isSet(object.x3xSoundOnPushToMuteUp)
        ? Sound.fromJSON(object.x3xSoundOnPushToMuteUp)
        : undefined,
      x3xSoundOnPushToMuteGlobalDown: isSet(object.x3xSoundOnPushToMuteGlobalDown)
        ? Sound.fromJSON(object.x3xSoundOnPushToMuteGlobalDown)
        : undefined,
      x3xSoundOnPushToMuteGlobalUp: isSet(object.x3xSoundOnPushToMuteGlobalUp)
        ? Sound.fromJSON(object.x3xSoundOnPushToMuteGlobalUp)
        : undefined,
      x3xSoundOnSetModeToVoiceActivity: isSet(object.x3xSoundOnSetModeToVoiceActivity)
        ? Sound.fromJSON(object.x3xSoundOnSetModeToVoiceActivity)
        : undefined,
      x3xSoundOnSetModeToTap: isSet(object.x3xSoundOnSetModeToTap)
        ? Sound.fromJSON(object.x3xSoundOnSetModeToTap)
        : undefined,
      x3xSoundOnSetModeToManual: isSet(object.x3xSoundOnSetModeToManual)
        ? Sound.fromJSON(object.x3xSoundOnSetModeToManual)
        : undefined,
      x3xSoundOnSetModeToTapOpenMicToPtt: isSet(object.x3xSoundOnSetModeToTapOpenMicToPtt)
        ? Sound.fromJSON(object.x3xSoundOnSetModeToTapOpenMicToPtt)
        : undefined,
      x3xSoundOnSetModeToManualOpenMicToPtt: isSet(object.x3xSoundOnSetModeToManualOpenMicToPtt)
        ? Sound.fromJSON(object.x3xSoundOnSetModeToManualOpenMicToPtt)
        : undefined,
      x3xSoundOnToggleMuteGlobalOn: isSet(object.x3xSoundOnToggleMuteGlobalOn)
        ? Sound.fromJSON(object.x3xSoundOnToggleMuteGlobalOn)
        : undefined,
      x3xSoundOnToggleMuteGlobalOff: isSet(object.x3xSoundOnToggleMuteGlobalOff)
        ? Sound.fromJSON(object.x3xSoundOnToggleMuteGlobalOff)
        : undefined,
      x3xSoundOnToggleMuteOn: isSet(object.x3xSoundOnToggleMuteOn)
        ? Sound.fromJSON(object.x3xSoundOnToggleMuteOn)
        : undefined,
      x3xSoundOnToggleMuteOff: isSet(object.x3xSoundOnToggleMuteOff)
        ? Sound.fromJSON(object.x3xSoundOnToggleMuteOff)
        : undefined,
      x3xPttSingle: isSet(object.x3xPttSingle) ? HotkeyV3.fromJSON(object.x3xPttSingle) : undefined,
      x3xKeyPushToMuteSingle: isSet(object.x3xKeyPushToMuteSingle)
        ? HotkeyV3.fromJSON(object.x3xKeyPushToMuteSingle)
        : undefined,
      x3xKeyPushToMuteGlobal: isSet(object.x3xKeyPushToMuteGlobal)
        ? HotkeyV3.fromJSON(object.x3xKeyPushToMuteGlobal)
        : undefined,
      x3xKeySetModeToVoiceActivity: isSet(object.x3xKeySetModeToVoiceActivity)
        ? HotkeyV3.fromJSON(object.x3xKeySetModeToVoiceActivity)
        : undefined,
      x3xKeySetModeToTap: isSet(object.x3xKeySetModeToTap) ? HotkeyV3.fromJSON(object.x3xKeySetModeToTap) : undefined,
      x3xKeySetModeToManual: isSet(object.x3xKeySetModeToManual)
        ? HotkeyV3.fromJSON(object.x3xKeySetModeToManual)
        : undefined,
      x3xKeySetModeToTapOpenMicToPtt: isSet(object.x3xKeySetModeToTapOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.x3xKeySetModeToTapOpenMicToPtt)
        : undefined,
      x3xKeySetModeToManualOpenMicToPtt: isSet(object.x3xKeySetModeToManualOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.x3xKeySetModeToManualOpenMicToPtt)
        : undefined,
      x3xKeySwapModeBetweenManualAndVoiceActivity: isSet(object.x3xKeySwapModeBetweenManualAndVoiceActivity)
        ? HotkeyV3.fromJSON(object.x3xKeySwapModeBetweenManualAndVoiceActivity)
        : undefined,
      x3xKeySwapModeBetweenManualAndTap: isSet(object.x3xKeySwapModeBetweenManualAndTap)
        ? HotkeyV3.fromJSON(object.x3xKeySwapModeBetweenManualAndTap)
        : undefined,
      x3xKeySwapModeBetweenManualAndManualOpenMicToPtt: isSet(object.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt)
        : undefined,
      x3xKeyToggleMuteGlobal: isSet(object.x3xKeyToggleMuteGlobal)
        ? HotkeyV3.fromJSON(object.x3xKeyToggleMuteGlobal)
        : undefined,
      x3xDeprecatedExtraTriggerKeys: globalThis.Array.isArray(object?.x3xDeprecatedExtraTriggerKeys)
        ? object.x3xDeprecatedExtraTriggerKeys.map((e: any) => HotkeyV3.fromJSON(e))
        : [],
      x3xOpenMicToPttConsumeInput: isSet(object.x3xOpenMicToPttConsumeInput)
        ? globalThis.Boolean(object.x3xOpenMicToPttConsumeInput)
        : false,
      x3xOverlayEnable: isSet(object.x3xOverlayEnable) ? globalThis.Boolean(object.x3xOverlayEnable) : false,
      x3xOverlaySettings: isSet(object.x3xOverlaySettings)
        ? OverlaySettings.fromJSON(object.x3xOverlaySettings)
        : undefined,
      x3xDeviceDisplayName: isSet(object.x3xDeviceDisplayName) ? globalThis.String(object.x3xDeviceDisplayName) : "",
      x3xKeyGroups: globalThis.Array.isArray(object?.x3xKeyGroups)
        ? object.x3xKeyGroups.map((e: any) => HotkeyGroup.fromJSON(e))
        : [],
      x3xUseTapActivationWindow: isSet(object.x3xUseTapActivationWindow)
        ? globalThis.Boolean(object.x3xUseTapActivationWindow)
        : false,
      x3xTapActivationWindowMs: isSet(object.x3xTapActivationWindowMs)
        ? globalThis.Number(object.x3xTapActivationWindowMs)
        : 0,
      x3xDeviceName: isSet(object.x3xDeviceName) ? globalThis.String(object.x3xDeviceName) : "",
      x3xDeviceUuid: isSet(object.x3xDeviceUuid) ? globalThis.String(object.x3xDeviceUuid) : "",
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.appVersion !== 0) {
      obj.appVersion = Math.round(message.appVersion);
    }
    if (message.selectedTab !== undefined) {
      obj.selectedTab = SelectedTab.toJSON(message.selectedTab);
    }
    if (message.startOnBootType !== 0) {
      obj.startOnBootType = startOnBootTypeToJSON(message.startOnBootType);
    }
    if (message.licenseKey !== "") {
      obj.licenseKey = message.licenseKey;
    }
    if (message.ipcAddr !== "") {
      obj.ipcAddr = message.ipcAddr;
    }
    if (message.minimizeToTray !== false) {
      obj.minimizeToTray = message.minimizeToTray;
    }
    if (message.updateCheck !== false) {
      obj.updateCheck = message.updateCheck;
    }
    if (message.useSidekick !== false) {
      obj.useSidekick = message.useSidekick;
    }
    if (message.autoProfileSwitch !== false) {
      obj.autoProfileSwitch = message.autoProfileSwitch;
    }
    if (message.profile !== 0) {
      obj.profile = Math.round(message.profile);
    }
    if (message.profiles?.length) {
      obj.profiles = message.profiles.map((e) => Profile.toJSON(e));
    }
    if (message.x3xThreshold !== 0) {
      obj.x3xThreshold = message.x3xThreshold;
    }
    if (message.x3xUseDeactThreshold !== false) {
      obj.x3xUseDeactThreshold = message.x3xUseDeactThreshold;
    }
    if (message.x3xDeactThreshold !== 0) {
      obj.x3xDeactThreshold = message.x3xDeactThreshold;
    }
    if (message.x3xSafe !== false) {
      obj.x3xSafe = message.x3xSafe;
    }
    if (message.x3xSafeIntervalMs !== 0) {
      obj.x3xSafeIntervalMs = Math.round(message.x3xSafeIntervalMs);
    }
    if (message.x3xDeprecatedUpdateIntervalMs !== 0) {
      obj.x3xDeprecatedUpdateIntervalMs = Math.round(message.x3xDeprecatedUpdateIntervalMs);
    }
    if (message.x3xReleaseDelayMs !== 0) {
      obj.x3xReleaseDelayMs = Math.round(message.x3xReleaseDelayMs);
    }
    if (message.x3xActivationMode !== 0) {
      obj.x3xActivationMode = activationModeToJSON(message.x3xActivationMode);
    }
    if (message.x3xMeterType !== 0) {
      obj.x3xMeterType = meterTypeToJSON(message.x3xMeterType);
    }
    if (message.x3xDeprecatedDeviceNameOrUuid !== "") {
      obj.x3xDeprecatedDeviceNameOrUuid = message.x3xDeprecatedDeviceNameOrUuid;
    }
    if (message.x3xSoundOnPttDown !== undefined) {
      obj.x3xSoundOnPttDown = Sound.toJSON(message.x3xSoundOnPttDown);
    }
    if (message.x3xSoundOnPttUp !== undefined) {
      obj.x3xSoundOnPttUp = Sound.toJSON(message.x3xSoundOnPttUp);
    }
    if (message.x3xSoundOnPushToMuteDown !== undefined) {
      obj.x3xSoundOnPushToMuteDown = Sound.toJSON(message.x3xSoundOnPushToMuteDown);
    }
    if (message.x3xSoundOnPushToMuteUp !== undefined) {
      obj.x3xSoundOnPushToMuteUp = Sound.toJSON(message.x3xSoundOnPushToMuteUp);
    }
    if (message.x3xSoundOnPushToMuteGlobalDown !== undefined) {
      obj.x3xSoundOnPushToMuteGlobalDown = Sound.toJSON(message.x3xSoundOnPushToMuteGlobalDown);
    }
    if (message.x3xSoundOnPushToMuteGlobalUp !== undefined) {
      obj.x3xSoundOnPushToMuteGlobalUp = Sound.toJSON(message.x3xSoundOnPushToMuteGlobalUp);
    }
    if (message.x3xSoundOnSetModeToVoiceActivity !== undefined) {
      obj.x3xSoundOnSetModeToVoiceActivity = Sound.toJSON(message.x3xSoundOnSetModeToVoiceActivity);
    }
    if (message.x3xSoundOnSetModeToTap !== undefined) {
      obj.x3xSoundOnSetModeToTap = Sound.toJSON(message.x3xSoundOnSetModeToTap);
    }
    if (message.x3xSoundOnSetModeToManual !== undefined) {
      obj.x3xSoundOnSetModeToManual = Sound.toJSON(message.x3xSoundOnSetModeToManual);
    }
    if (message.x3xSoundOnSetModeToTapOpenMicToPtt !== undefined) {
      obj.x3xSoundOnSetModeToTapOpenMicToPtt = Sound.toJSON(message.x3xSoundOnSetModeToTapOpenMicToPtt);
    }
    if (message.x3xSoundOnSetModeToManualOpenMicToPtt !== undefined) {
      obj.x3xSoundOnSetModeToManualOpenMicToPtt = Sound.toJSON(message.x3xSoundOnSetModeToManualOpenMicToPtt);
    }
    if (message.x3xSoundOnToggleMuteGlobalOn !== undefined) {
      obj.x3xSoundOnToggleMuteGlobalOn = Sound.toJSON(message.x3xSoundOnToggleMuteGlobalOn);
    }
    if (message.x3xSoundOnToggleMuteGlobalOff !== undefined) {
      obj.x3xSoundOnToggleMuteGlobalOff = Sound.toJSON(message.x3xSoundOnToggleMuteGlobalOff);
    }
    if (message.x3xSoundOnToggleMuteOn !== undefined) {
      obj.x3xSoundOnToggleMuteOn = Sound.toJSON(message.x3xSoundOnToggleMuteOn);
    }
    if (message.x3xSoundOnToggleMuteOff !== undefined) {
      obj.x3xSoundOnToggleMuteOff = Sound.toJSON(message.x3xSoundOnToggleMuteOff);
    }
    if (message.x3xPttSingle !== undefined) {
      obj.x3xPttSingle = HotkeyV3.toJSON(message.x3xPttSingle);
    }
    if (message.x3xKeyPushToMuteSingle !== undefined) {
      obj.x3xKeyPushToMuteSingle = HotkeyV3.toJSON(message.x3xKeyPushToMuteSingle);
    }
    if (message.x3xKeyPushToMuteGlobal !== undefined) {
      obj.x3xKeyPushToMuteGlobal = HotkeyV3.toJSON(message.x3xKeyPushToMuteGlobal);
    }
    if (message.x3xKeySetModeToVoiceActivity !== undefined) {
      obj.x3xKeySetModeToVoiceActivity = HotkeyV3.toJSON(message.x3xKeySetModeToVoiceActivity);
    }
    if (message.x3xKeySetModeToTap !== undefined) {
      obj.x3xKeySetModeToTap = HotkeyV3.toJSON(message.x3xKeySetModeToTap);
    }
    if (message.x3xKeySetModeToManual !== undefined) {
      obj.x3xKeySetModeToManual = HotkeyV3.toJSON(message.x3xKeySetModeToManual);
    }
    if (message.x3xKeySetModeToTapOpenMicToPtt !== undefined) {
      obj.x3xKeySetModeToTapOpenMicToPtt = HotkeyV3.toJSON(message.x3xKeySetModeToTapOpenMicToPtt);
    }
    if (message.x3xKeySetModeToManualOpenMicToPtt !== undefined) {
      obj.x3xKeySetModeToManualOpenMicToPtt = HotkeyV3.toJSON(message.x3xKeySetModeToManualOpenMicToPtt);
    }
    if (message.x3xKeySwapModeBetweenManualAndVoiceActivity !== undefined) {
      obj.x3xKeySwapModeBetweenManualAndVoiceActivity = HotkeyV3.toJSON(
        message.x3xKeySwapModeBetweenManualAndVoiceActivity,
      );
    }
    if (message.x3xKeySwapModeBetweenManualAndTap !== undefined) {
      obj.x3xKeySwapModeBetweenManualAndTap = HotkeyV3.toJSON(message.x3xKeySwapModeBetweenManualAndTap);
    }
    if (message.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt !== undefined) {
      obj.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt = HotkeyV3.toJSON(
        message.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt,
      );
    }
    if (message.x3xKeyToggleMuteGlobal !== undefined) {
      obj.x3xKeyToggleMuteGlobal = HotkeyV3.toJSON(message.x3xKeyToggleMuteGlobal);
    }
    if (message.x3xDeprecatedExtraTriggerKeys?.length) {
      obj.x3xDeprecatedExtraTriggerKeys = message.x3xDeprecatedExtraTriggerKeys.map((e) => HotkeyV3.toJSON(e));
    }
    if (message.x3xOpenMicToPttConsumeInput !== false) {
      obj.x3xOpenMicToPttConsumeInput = message.x3xOpenMicToPttConsumeInput;
    }
    if (message.x3xOverlayEnable !== false) {
      obj.x3xOverlayEnable = message.x3xOverlayEnable;
    }
    if (message.x3xOverlaySettings !== undefined) {
      obj.x3xOverlaySettings = OverlaySettings.toJSON(message.x3xOverlaySettings);
    }
    if (message.x3xDeviceDisplayName !== "") {
      obj.x3xDeviceDisplayName = message.x3xDeviceDisplayName;
    }
    if (message.x3xKeyGroups?.length) {
      obj.x3xKeyGroups = message.x3xKeyGroups.map((e) => HotkeyGroup.toJSON(e));
    }
    if (message.x3xUseTapActivationWindow !== false) {
      obj.x3xUseTapActivationWindow = message.x3xUseTapActivationWindow;
    }
    if (message.x3xTapActivationWindowMs !== 0) {
      obj.x3xTapActivationWindowMs = Math.round(message.x3xTapActivationWindowMs);
    }
    if (message.x3xDeviceName !== "") {
      obj.x3xDeviceName = message.x3xDeviceName;
    }
    if (message.x3xDeviceUuid !== "") {
      obj.x3xDeviceUuid = message.x3xDeviceUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Settings>, I>>(base?: I): Settings {
    return Settings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settings>, I>>(object: I): Settings {
    const message = createBaseSettings();
    message.version = object.version ?? 0;
    message.appVersion = object.appVersion ?? 0;
    message.selectedTab = (object.selectedTab !== undefined && object.selectedTab !== null)
      ? SelectedTab.fromPartial(object.selectedTab)
      : undefined;
    message.startOnBootType = object.startOnBootType ?? 0;
    message.licenseKey = object.licenseKey ?? "";
    message.ipcAddr = object.ipcAddr ?? "";
    message.minimizeToTray = object.minimizeToTray ?? false;
    message.updateCheck = object.updateCheck ?? false;
    message.useSidekick = object.useSidekick ?? false;
    message.autoProfileSwitch = object.autoProfileSwitch ?? false;
    message.profile = object.profile ?? 0;
    message.profiles = object.profiles?.map((e) => Profile.fromPartial(e)) || [];
    message.x3xThreshold = object.x3xThreshold ?? 0;
    message.x3xUseDeactThreshold = object.x3xUseDeactThreshold ?? false;
    message.x3xDeactThreshold = object.x3xDeactThreshold ?? 0;
    message.x3xSafe = object.x3xSafe ?? false;
    message.x3xSafeIntervalMs = object.x3xSafeIntervalMs ?? 0;
    message.x3xDeprecatedUpdateIntervalMs = object.x3xDeprecatedUpdateIntervalMs ?? 0;
    message.x3xReleaseDelayMs = object.x3xReleaseDelayMs ?? 0;
    message.x3xActivationMode = object.x3xActivationMode ?? 0;
    message.x3xMeterType = object.x3xMeterType ?? 0;
    message.x3xDeprecatedDeviceNameOrUuid = object.x3xDeprecatedDeviceNameOrUuid ?? "";
    message.x3xSoundOnPttDown = (object.x3xSoundOnPttDown !== undefined && object.x3xSoundOnPttDown !== null)
      ? Sound.fromPartial(object.x3xSoundOnPttDown)
      : undefined;
    message.x3xSoundOnPttUp = (object.x3xSoundOnPttUp !== undefined && object.x3xSoundOnPttUp !== null)
      ? Sound.fromPartial(object.x3xSoundOnPttUp)
      : undefined;
    message.x3xSoundOnPushToMuteDown =
      (object.x3xSoundOnPushToMuteDown !== undefined && object.x3xSoundOnPushToMuteDown !== null)
        ? Sound.fromPartial(object.x3xSoundOnPushToMuteDown)
        : undefined;
    message.x3xSoundOnPushToMuteUp =
      (object.x3xSoundOnPushToMuteUp !== undefined && object.x3xSoundOnPushToMuteUp !== null)
        ? Sound.fromPartial(object.x3xSoundOnPushToMuteUp)
        : undefined;
    message.x3xSoundOnPushToMuteGlobalDown =
      (object.x3xSoundOnPushToMuteGlobalDown !== undefined && object.x3xSoundOnPushToMuteGlobalDown !== null)
        ? Sound.fromPartial(object.x3xSoundOnPushToMuteGlobalDown)
        : undefined;
    message.x3xSoundOnPushToMuteGlobalUp =
      (object.x3xSoundOnPushToMuteGlobalUp !== undefined && object.x3xSoundOnPushToMuteGlobalUp !== null)
        ? Sound.fromPartial(object.x3xSoundOnPushToMuteGlobalUp)
        : undefined;
    message.x3xSoundOnSetModeToVoiceActivity =
      (object.x3xSoundOnSetModeToVoiceActivity !== undefined && object.x3xSoundOnSetModeToVoiceActivity !== null)
        ? Sound.fromPartial(object.x3xSoundOnSetModeToVoiceActivity)
        : undefined;
    message.x3xSoundOnSetModeToTap =
      (object.x3xSoundOnSetModeToTap !== undefined && object.x3xSoundOnSetModeToTap !== null)
        ? Sound.fromPartial(object.x3xSoundOnSetModeToTap)
        : undefined;
    message.x3xSoundOnSetModeToManual =
      (object.x3xSoundOnSetModeToManual !== undefined && object.x3xSoundOnSetModeToManual !== null)
        ? Sound.fromPartial(object.x3xSoundOnSetModeToManual)
        : undefined;
    message.x3xSoundOnSetModeToTapOpenMicToPtt =
      (object.x3xSoundOnSetModeToTapOpenMicToPtt !== undefined && object.x3xSoundOnSetModeToTapOpenMicToPtt !== null)
        ? Sound.fromPartial(object.x3xSoundOnSetModeToTapOpenMicToPtt)
        : undefined;
    message.x3xSoundOnSetModeToManualOpenMicToPtt =
      (object.x3xSoundOnSetModeToManualOpenMicToPtt !== undefined &&
          object.x3xSoundOnSetModeToManualOpenMicToPtt !== null)
        ? Sound.fromPartial(object.x3xSoundOnSetModeToManualOpenMicToPtt)
        : undefined;
    message.x3xSoundOnToggleMuteGlobalOn =
      (object.x3xSoundOnToggleMuteGlobalOn !== undefined && object.x3xSoundOnToggleMuteGlobalOn !== null)
        ? Sound.fromPartial(object.x3xSoundOnToggleMuteGlobalOn)
        : undefined;
    message.x3xSoundOnToggleMuteGlobalOff =
      (object.x3xSoundOnToggleMuteGlobalOff !== undefined && object.x3xSoundOnToggleMuteGlobalOff !== null)
        ? Sound.fromPartial(object.x3xSoundOnToggleMuteGlobalOff)
        : undefined;
    message.x3xSoundOnToggleMuteOn =
      (object.x3xSoundOnToggleMuteOn !== undefined && object.x3xSoundOnToggleMuteOn !== null)
        ? Sound.fromPartial(object.x3xSoundOnToggleMuteOn)
        : undefined;
    message.x3xSoundOnToggleMuteOff =
      (object.x3xSoundOnToggleMuteOff !== undefined && object.x3xSoundOnToggleMuteOff !== null)
        ? Sound.fromPartial(object.x3xSoundOnToggleMuteOff)
        : undefined;
    message.x3xPttSingle = (object.x3xPttSingle !== undefined && object.x3xPttSingle !== null)
      ? HotkeyV3.fromPartial(object.x3xPttSingle)
      : undefined;
    message.x3xKeyPushToMuteSingle =
      (object.x3xKeyPushToMuteSingle !== undefined && object.x3xKeyPushToMuteSingle !== null)
        ? HotkeyV3.fromPartial(object.x3xKeyPushToMuteSingle)
        : undefined;
    message.x3xKeyPushToMuteGlobal =
      (object.x3xKeyPushToMuteGlobal !== undefined && object.x3xKeyPushToMuteGlobal !== null)
        ? HotkeyV3.fromPartial(object.x3xKeyPushToMuteGlobal)
        : undefined;
    message.x3xKeySetModeToVoiceActivity =
      (object.x3xKeySetModeToVoiceActivity !== undefined && object.x3xKeySetModeToVoiceActivity !== null)
        ? HotkeyV3.fromPartial(object.x3xKeySetModeToVoiceActivity)
        : undefined;
    message.x3xKeySetModeToTap = (object.x3xKeySetModeToTap !== undefined && object.x3xKeySetModeToTap !== null)
      ? HotkeyV3.fromPartial(object.x3xKeySetModeToTap)
      : undefined;
    message.x3xKeySetModeToManual =
      (object.x3xKeySetModeToManual !== undefined && object.x3xKeySetModeToManual !== null)
        ? HotkeyV3.fromPartial(object.x3xKeySetModeToManual)
        : undefined;
    message.x3xKeySetModeToTapOpenMicToPtt =
      (object.x3xKeySetModeToTapOpenMicToPtt !== undefined && object.x3xKeySetModeToTapOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.x3xKeySetModeToTapOpenMicToPtt)
        : undefined;
    message.x3xKeySetModeToManualOpenMicToPtt =
      (object.x3xKeySetModeToManualOpenMicToPtt !== undefined && object.x3xKeySetModeToManualOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.x3xKeySetModeToManualOpenMicToPtt)
        : undefined;
    message.x3xKeySwapModeBetweenManualAndVoiceActivity =
      (object.x3xKeySwapModeBetweenManualAndVoiceActivity !== undefined &&
          object.x3xKeySwapModeBetweenManualAndVoiceActivity !== null)
        ? HotkeyV3.fromPartial(object.x3xKeySwapModeBetweenManualAndVoiceActivity)
        : undefined;
    message.x3xKeySwapModeBetweenManualAndTap =
      (object.x3xKeySwapModeBetweenManualAndTap !== undefined && object.x3xKeySwapModeBetweenManualAndTap !== null)
        ? HotkeyV3.fromPartial(object.x3xKeySwapModeBetweenManualAndTap)
        : undefined;
    message.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt =
      (object.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt !== undefined &&
          object.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.x3xKeySwapModeBetweenManualAndManualOpenMicToPtt)
        : undefined;
    message.x3xKeyToggleMuteGlobal =
      (object.x3xKeyToggleMuteGlobal !== undefined && object.x3xKeyToggleMuteGlobal !== null)
        ? HotkeyV3.fromPartial(object.x3xKeyToggleMuteGlobal)
        : undefined;
    message.x3xDeprecatedExtraTriggerKeys = object.x3xDeprecatedExtraTriggerKeys?.map((e) => HotkeyV3.fromPartial(e)) ||
      [];
    message.x3xOpenMicToPttConsumeInput = object.x3xOpenMicToPttConsumeInput ?? false;
    message.x3xOverlayEnable = object.x3xOverlayEnable ?? false;
    message.x3xOverlaySettings = (object.x3xOverlaySettings !== undefined && object.x3xOverlaySettings !== null)
      ? OverlaySettings.fromPartial(object.x3xOverlaySettings)
      : undefined;
    message.x3xDeviceDisplayName = object.x3xDeviceDisplayName ?? "";
    message.x3xKeyGroups = object.x3xKeyGroups?.map((e) => HotkeyGroup.fromPartial(e)) || [];
    message.x3xUseTapActivationWindow = object.x3xUseTapActivationWindow ?? false;
    message.x3xTapActivationWindowMs = object.x3xTapActivationWindowMs ?? 0;
    message.x3xDeviceName = object.x3xDeviceName ?? "";
    message.x3xDeviceUuid = object.x3xDeviceUuid ?? "";
    return message;
  },
};

function createBaseProfile(): Profile {
  return { id: new Uint8Array(0), name: "", activationTriggers: [], settings: undefined };
}

export const Profile: MessageFns<Profile> = {
  encode(message: Profile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.activationTriggers) {
      ProfileActivationTrigger.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.settings !== undefined) {
      ProfileSettings.encode(message.settings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Profile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.activationTriggers.push(ProfileActivationTrigger.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.settings = ProfileSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Profile {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      activationTriggers: globalThis.Array.isArray(object?.activationTriggers)
        ? object.activationTriggers.map((e: any) => ProfileActivationTrigger.fromJSON(e))
        : [],
      settings: isSet(object.settings) ? ProfileSettings.fromJSON(object.settings) : undefined,
    };
  },

  toJSON(message: Profile): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.activationTriggers?.length) {
      obj.activationTriggers = message.activationTriggers.map((e) => ProfileActivationTrigger.toJSON(e));
    }
    if (message.settings !== undefined) {
      obj.settings = ProfileSettings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Profile>, I>>(base?: I): Profile {
    return Profile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Profile>, I>>(object: I): Profile {
    const message = createBaseProfile();
    message.id = object.id ?? new Uint8Array(0);
    message.name = object.name ?? "";
    message.activationTriggers = object.activationTriggers?.map((e) => ProfileActivationTrigger.fromPartial(e)) || [];
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? ProfileSettings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseProfileSettings(): ProfileSettings {
  return {
    threshold: 0,
    useDeactThreshold: false,
    deactThreshold: 0,
    safe: false,
    safeIntervalMs: 0,
    releaseDelayMs: 0,
    activationMode: 0,
    meterType: 0,
    soundOnPttDown: undefined,
    soundOnPttUp: undefined,
    soundOnPushToMuteDown: undefined,
    soundOnPushToMuteUp: undefined,
    soundOnPushToMuteGlobalDown: undefined,
    soundOnPushToMuteGlobalUp: undefined,
    soundOnSetModeToVoiceActivity: undefined,
    soundOnSetModeToTap: undefined,
    soundOnSetModeToManual: undefined,
    soundOnSetModeToTapOpenMicToPtt: undefined,
    soundOnSetModeToManualOpenMicToPtt: undefined,
    soundOnToggleMuteGlobalOn: undefined,
    soundOnToggleMuteGlobalOff: undefined,
    soundOnToggleMuteOn: undefined,
    soundOnToggleMuteOff: undefined,
    keyPushToMuteGlobal: undefined,
    keySetModeToVoiceActivity: undefined,
    keySetModeToTap: undefined,
    keySetModeToManual: undefined,
    keySetModeToTapOpenMicToPtt: undefined,
    keySetModeToManualOpenMicToPtt: undefined,
    keySwapModeBetweenManualAndVoiceActivity: undefined,
    keySwapModeBetweenManualAndTap: undefined,
    keySwapModeBetweenManualAndManualOpenMicToPtt: undefined,
    keyToggleMuteGlobal: undefined,
    openMicToPttConsumeInput: false,
    overlayEnable: false,
    overlaySettings: undefined,
    deviceDisplayName: "",
    keyGroups: [],
    useTapActivationWindow: false,
    tapActivationWindowMs: 0,
    deviceName: "",
    deviceUuid: "",
  };
}

export const ProfileSettings: MessageFns<ProfileSettings> = {
  encode(message: ProfileSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threshold !== 0) {
      writer.uint32(9).double(message.threshold);
    }
    if (message.useDeactThreshold !== false) {
      writer.uint32(16).bool(message.useDeactThreshold);
    }
    if (message.deactThreshold !== 0) {
      writer.uint32(25).double(message.deactThreshold);
    }
    if (message.safe !== false) {
      writer.uint32(32).bool(message.safe);
    }
    if (message.safeIntervalMs !== 0) {
      writer.uint32(40).uint32(message.safeIntervalMs);
    }
    if (message.releaseDelayMs !== 0) {
      writer.uint32(56).uint32(message.releaseDelayMs);
    }
    if (message.activationMode !== 0) {
      writer.uint32(64).int32(message.activationMode);
    }
    if (message.meterType !== 0) {
      writer.uint32(72).int32(message.meterType);
    }
    if (message.soundOnPttDown !== undefined) {
      Sound.encode(message.soundOnPttDown, writer.uint32(82).fork()).join();
    }
    if (message.soundOnPttUp !== undefined) {
      Sound.encode(message.soundOnPttUp, writer.uint32(90).fork()).join();
    }
    if (message.soundOnPushToMuteDown !== undefined) {
      Sound.encode(message.soundOnPushToMuteDown, writer.uint32(98).fork()).join();
    }
    if (message.soundOnPushToMuteUp !== undefined) {
      Sound.encode(message.soundOnPushToMuteUp, writer.uint32(106).fork()).join();
    }
    if (message.soundOnPushToMuteGlobalDown !== undefined) {
      Sound.encode(message.soundOnPushToMuteGlobalDown, writer.uint32(114).fork()).join();
    }
    if (message.soundOnPushToMuteGlobalUp !== undefined) {
      Sound.encode(message.soundOnPushToMuteGlobalUp, writer.uint32(122).fork()).join();
    }
    if (message.soundOnSetModeToVoiceActivity !== undefined) {
      Sound.encode(message.soundOnSetModeToVoiceActivity, writer.uint32(130).fork()).join();
    }
    if (message.soundOnSetModeToTap !== undefined) {
      Sound.encode(message.soundOnSetModeToTap, writer.uint32(138).fork()).join();
    }
    if (message.soundOnSetModeToManual !== undefined) {
      Sound.encode(message.soundOnSetModeToManual, writer.uint32(146).fork()).join();
    }
    if (message.soundOnSetModeToTapOpenMicToPtt !== undefined) {
      Sound.encode(message.soundOnSetModeToTapOpenMicToPtt, writer.uint32(154).fork()).join();
    }
    if (message.soundOnSetModeToManualOpenMicToPtt !== undefined) {
      Sound.encode(message.soundOnSetModeToManualOpenMicToPtt, writer.uint32(162).fork()).join();
    }
    if (message.soundOnToggleMuteGlobalOn !== undefined) {
      Sound.encode(message.soundOnToggleMuteGlobalOn, writer.uint32(170).fork()).join();
    }
    if (message.soundOnToggleMuteGlobalOff !== undefined) {
      Sound.encode(message.soundOnToggleMuteGlobalOff, writer.uint32(178).fork()).join();
    }
    if (message.soundOnToggleMuteOn !== undefined) {
      Sound.encode(message.soundOnToggleMuteOn, writer.uint32(186).fork()).join();
    }
    if (message.soundOnToggleMuteOff !== undefined) {
      Sound.encode(message.soundOnToggleMuteOff, writer.uint32(194).fork()).join();
    }
    if (message.keyPushToMuteGlobal !== undefined) {
      HotkeyV3.encode(message.keyPushToMuteGlobal, writer.uint32(202).fork()).join();
    }
    if (message.keySetModeToVoiceActivity !== undefined) {
      HotkeyV3.encode(message.keySetModeToVoiceActivity, writer.uint32(210).fork()).join();
    }
    if (message.keySetModeToTap !== undefined) {
      HotkeyV3.encode(message.keySetModeToTap, writer.uint32(218).fork()).join();
    }
    if (message.keySetModeToManual !== undefined) {
      HotkeyV3.encode(message.keySetModeToManual, writer.uint32(226).fork()).join();
    }
    if (message.keySetModeToTapOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.keySetModeToTapOpenMicToPtt, writer.uint32(234).fork()).join();
    }
    if (message.keySetModeToManualOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.keySetModeToManualOpenMicToPtt, writer.uint32(242).fork()).join();
    }
    if (message.keySwapModeBetweenManualAndVoiceActivity !== undefined) {
      HotkeyV3.encode(message.keySwapModeBetweenManualAndVoiceActivity, writer.uint32(250).fork()).join();
    }
    if (message.keySwapModeBetweenManualAndTap !== undefined) {
      HotkeyV3.encode(message.keySwapModeBetweenManualAndTap, writer.uint32(258).fork()).join();
    }
    if (message.keySwapModeBetweenManualAndManualOpenMicToPtt !== undefined) {
      HotkeyV3.encode(message.keySwapModeBetweenManualAndManualOpenMicToPtt, writer.uint32(266).fork()).join();
    }
    if (message.keyToggleMuteGlobal !== undefined) {
      HotkeyV3.encode(message.keyToggleMuteGlobal, writer.uint32(274).fork()).join();
    }
    if (message.openMicToPttConsumeInput !== false) {
      writer.uint32(280).bool(message.openMicToPttConsumeInput);
    }
    if (message.overlayEnable !== false) {
      writer.uint32(288).bool(message.overlayEnable);
    }
    if (message.overlaySettings !== undefined) {
      OverlaySettings.encode(message.overlaySettings, writer.uint32(298).fork()).join();
    }
    if (message.deviceDisplayName !== "") {
      writer.uint32(306).string(message.deviceDisplayName);
    }
    for (const v of message.keyGroups) {
      HotkeyGroup.encode(v!, writer.uint32(314).fork()).join();
    }
    if (message.useTapActivationWindow !== false) {
      writer.uint32(320).bool(message.useTapActivationWindow);
    }
    if (message.tapActivationWindowMs !== 0) {
      writer.uint32(328).uint32(message.tapActivationWindowMs);
    }
    if (message.deviceName !== "") {
      writer.uint32(338).string(message.deviceName);
    }
    if (message.deviceUuid !== "") {
      writer.uint32(346).string(message.deviceUuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.threshold = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.useDeactThreshold = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.deactThreshold = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.safe = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.safeIntervalMs = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.releaseDelayMs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.activationMode = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.meterType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.soundOnPttDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.soundOnPttUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.soundOnPushToMuteDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.soundOnPushToMuteUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.soundOnPushToMuteGlobalDown = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.soundOnPushToMuteGlobalUp = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.soundOnSetModeToVoiceActivity = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.soundOnSetModeToTap = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.soundOnSetModeToManual = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.soundOnSetModeToTapOpenMicToPtt = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.soundOnSetModeToManualOpenMicToPtt = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.soundOnToggleMuteGlobalOn = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.soundOnToggleMuteGlobalOff = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.soundOnToggleMuteOn = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.soundOnToggleMuteOff = Sound.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.keyPushToMuteGlobal = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.keySetModeToVoiceActivity = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.keySetModeToTap = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.keySetModeToManual = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.keySetModeToTapOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.keySetModeToManualOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.keySwapModeBetweenManualAndVoiceActivity = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.keySwapModeBetweenManualAndTap = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.keySwapModeBetweenManualAndManualOpenMicToPtt = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.keyToggleMuteGlobal = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.openMicToPttConsumeInput = reader.bool();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.overlayEnable = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.overlaySettings = OverlaySettings.decode(reader, reader.uint32());
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.deviceDisplayName = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.keyGroups.push(HotkeyGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }

          message.useTapActivationWindow = reader.bool();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }

          message.tapActivationWindowMs = reader.uint32();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.deviceUuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileSettings {
    return {
      threshold: isSet(object.threshold) ? globalThis.Number(object.threshold) : 0,
      useDeactThreshold: isSet(object.useDeactThreshold) ? globalThis.Boolean(object.useDeactThreshold) : false,
      deactThreshold: isSet(object.deactThreshold) ? globalThis.Number(object.deactThreshold) : 0,
      safe: isSet(object.safe) ? globalThis.Boolean(object.safe) : false,
      safeIntervalMs: isSet(object.safeIntervalMs) ? globalThis.Number(object.safeIntervalMs) : 0,
      releaseDelayMs: isSet(object.releaseDelayMs) ? globalThis.Number(object.releaseDelayMs) : 0,
      activationMode: isSet(object.activationMode) ? activationModeFromJSON(object.activationMode) : 0,
      meterType: isSet(object.meterType) ? meterTypeFromJSON(object.meterType) : 0,
      soundOnPttDown: isSet(object.soundOnPttDown) ? Sound.fromJSON(object.soundOnPttDown) : undefined,
      soundOnPttUp: isSet(object.soundOnPttUp) ? Sound.fromJSON(object.soundOnPttUp) : undefined,
      soundOnPushToMuteDown: isSet(object.soundOnPushToMuteDown)
        ? Sound.fromJSON(object.soundOnPushToMuteDown)
        : undefined,
      soundOnPushToMuteUp: isSet(object.soundOnPushToMuteUp) ? Sound.fromJSON(object.soundOnPushToMuteUp) : undefined,
      soundOnPushToMuteGlobalDown: isSet(object.soundOnPushToMuteGlobalDown)
        ? Sound.fromJSON(object.soundOnPushToMuteGlobalDown)
        : undefined,
      soundOnPushToMuteGlobalUp: isSet(object.soundOnPushToMuteGlobalUp)
        ? Sound.fromJSON(object.soundOnPushToMuteGlobalUp)
        : undefined,
      soundOnSetModeToVoiceActivity: isSet(object.soundOnSetModeToVoiceActivity)
        ? Sound.fromJSON(object.soundOnSetModeToVoiceActivity)
        : undefined,
      soundOnSetModeToTap: isSet(object.soundOnSetModeToTap) ? Sound.fromJSON(object.soundOnSetModeToTap) : undefined,
      soundOnSetModeToManual: isSet(object.soundOnSetModeToManual)
        ? Sound.fromJSON(object.soundOnSetModeToManual)
        : undefined,
      soundOnSetModeToTapOpenMicToPtt: isSet(object.soundOnSetModeToTapOpenMicToPtt)
        ? Sound.fromJSON(object.soundOnSetModeToTapOpenMicToPtt)
        : undefined,
      soundOnSetModeToManualOpenMicToPtt: isSet(object.soundOnSetModeToManualOpenMicToPtt)
        ? Sound.fromJSON(object.soundOnSetModeToManualOpenMicToPtt)
        : undefined,
      soundOnToggleMuteGlobalOn: isSet(object.soundOnToggleMuteGlobalOn)
        ? Sound.fromJSON(object.soundOnToggleMuteGlobalOn)
        : undefined,
      soundOnToggleMuteGlobalOff: isSet(object.soundOnToggleMuteGlobalOff)
        ? Sound.fromJSON(object.soundOnToggleMuteGlobalOff)
        : undefined,
      soundOnToggleMuteOn: isSet(object.soundOnToggleMuteOn) ? Sound.fromJSON(object.soundOnToggleMuteOn) : undefined,
      soundOnToggleMuteOff: isSet(object.soundOnToggleMuteOff)
        ? Sound.fromJSON(object.soundOnToggleMuteOff)
        : undefined,
      keyPushToMuteGlobal: isSet(object.keyPushToMuteGlobal)
        ? HotkeyV3.fromJSON(object.keyPushToMuteGlobal)
        : undefined,
      keySetModeToVoiceActivity: isSet(object.keySetModeToVoiceActivity)
        ? HotkeyV3.fromJSON(object.keySetModeToVoiceActivity)
        : undefined,
      keySetModeToTap: isSet(object.keySetModeToTap) ? HotkeyV3.fromJSON(object.keySetModeToTap) : undefined,
      keySetModeToManual: isSet(object.keySetModeToManual) ? HotkeyV3.fromJSON(object.keySetModeToManual) : undefined,
      keySetModeToTapOpenMicToPtt: isSet(object.keySetModeToTapOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.keySetModeToTapOpenMicToPtt)
        : undefined,
      keySetModeToManualOpenMicToPtt: isSet(object.keySetModeToManualOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.keySetModeToManualOpenMicToPtt)
        : undefined,
      keySwapModeBetweenManualAndVoiceActivity: isSet(object.keySwapModeBetweenManualAndVoiceActivity)
        ? HotkeyV3.fromJSON(object.keySwapModeBetweenManualAndVoiceActivity)
        : undefined,
      keySwapModeBetweenManualAndTap: isSet(object.keySwapModeBetweenManualAndTap)
        ? HotkeyV3.fromJSON(object.keySwapModeBetweenManualAndTap)
        : undefined,
      keySwapModeBetweenManualAndManualOpenMicToPtt: isSet(object.keySwapModeBetweenManualAndManualOpenMicToPtt)
        ? HotkeyV3.fromJSON(object.keySwapModeBetweenManualAndManualOpenMicToPtt)
        : undefined,
      keyToggleMuteGlobal: isSet(object.keyToggleMuteGlobal)
        ? HotkeyV3.fromJSON(object.keyToggleMuteGlobal)
        : undefined,
      openMicToPttConsumeInput: isSet(object.openMicToPttConsumeInput)
        ? globalThis.Boolean(object.openMicToPttConsumeInput)
        : false,
      overlayEnable: isSet(object.overlayEnable) ? globalThis.Boolean(object.overlayEnable) : false,
      overlaySettings: isSet(object.overlaySettings) ? OverlaySettings.fromJSON(object.overlaySettings) : undefined,
      deviceDisplayName: isSet(object.deviceDisplayName) ? globalThis.String(object.deviceDisplayName) : "",
      keyGroups: globalThis.Array.isArray(object?.keyGroups)
        ? object.keyGroups.map((e: any) => HotkeyGroup.fromJSON(e))
        : [],
      useTapActivationWindow: isSet(object.useTapActivationWindow)
        ? globalThis.Boolean(object.useTapActivationWindow)
        : false,
      tapActivationWindowMs: isSet(object.tapActivationWindowMs) ? globalThis.Number(object.tapActivationWindowMs) : 0,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : "",
      deviceUuid: isSet(object.deviceUuid) ? globalThis.String(object.deviceUuid) : "",
    };
  },

  toJSON(message: ProfileSettings): unknown {
    const obj: any = {};
    if (message.threshold !== 0) {
      obj.threshold = message.threshold;
    }
    if (message.useDeactThreshold !== false) {
      obj.useDeactThreshold = message.useDeactThreshold;
    }
    if (message.deactThreshold !== 0) {
      obj.deactThreshold = message.deactThreshold;
    }
    if (message.safe !== false) {
      obj.safe = message.safe;
    }
    if (message.safeIntervalMs !== 0) {
      obj.safeIntervalMs = Math.round(message.safeIntervalMs);
    }
    if (message.releaseDelayMs !== 0) {
      obj.releaseDelayMs = Math.round(message.releaseDelayMs);
    }
    if (message.activationMode !== 0) {
      obj.activationMode = activationModeToJSON(message.activationMode);
    }
    if (message.meterType !== 0) {
      obj.meterType = meterTypeToJSON(message.meterType);
    }
    if (message.soundOnPttDown !== undefined) {
      obj.soundOnPttDown = Sound.toJSON(message.soundOnPttDown);
    }
    if (message.soundOnPttUp !== undefined) {
      obj.soundOnPttUp = Sound.toJSON(message.soundOnPttUp);
    }
    if (message.soundOnPushToMuteDown !== undefined) {
      obj.soundOnPushToMuteDown = Sound.toJSON(message.soundOnPushToMuteDown);
    }
    if (message.soundOnPushToMuteUp !== undefined) {
      obj.soundOnPushToMuteUp = Sound.toJSON(message.soundOnPushToMuteUp);
    }
    if (message.soundOnPushToMuteGlobalDown !== undefined) {
      obj.soundOnPushToMuteGlobalDown = Sound.toJSON(message.soundOnPushToMuteGlobalDown);
    }
    if (message.soundOnPushToMuteGlobalUp !== undefined) {
      obj.soundOnPushToMuteGlobalUp = Sound.toJSON(message.soundOnPushToMuteGlobalUp);
    }
    if (message.soundOnSetModeToVoiceActivity !== undefined) {
      obj.soundOnSetModeToVoiceActivity = Sound.toJSON(message.soundOnSetModeToVoiceActivity);
    }
    if (message.soundOnSetModeToTap !== undefined) {
      obj.soundOnSetModeToTap = Sound.toJSON(message.soundOnSetModeToTap);
    }
    if (message.soundOnSetModeToManual !== undefined) {
      obj.soundOnSetModeToManual = Sound.toJSON(message.soundOnSetModeToManual);
    }
    if (message.soundOnSetModeToTapOpenMicToPtt !== undefined) {
      obj.soundOnSetModeToTapOpenMicToPtt = Sound.toJSON(message.soundOnSetModeToTapOpenMicToPtt);
    }
    if (message.soundOnSetModeToManualOpenMicToPtt !== undefined) {
      obj.soundOnSetModeToManualOpenMicToPtt = Sound.toJSON(message.soundOnSetModeToManualOpenMicToPtt);
    }
    if (message.soundOnToggleMuteGlobalOn !== undefined) {
      obj.soundOnToggleMuteGlobalOn = Sound.toJSON(message.soundOnToggleMuteGlobalOn);
    }
    if (message.soundOnToggleMuteGlobalOff !== undefined) {
      obj.soundOnToggleMuteGlobalOff = Sound.toJSON(message.soundOnToggleMuteGlobalOff);
    }
    if (message.soundOnToggleMuteOn !== undefined) {
      obj.soundOnToggleMuteOn = Sound.toJSON(message.soundOnToggleMuteOn);
    }
    if (message.soundOnToggleMuteOff !== undefined) {
      obj.soundOnToggleMuteOff = Sound.toJSON(message.soundOnToggleMuteOff);
    }
    if (message.keyPushToMuteGlobal !== undefined) {
      obj.keyPushToMuteGlobal = HotkeyV3.toJSON(message.keyPushToMuteGlobal);
    }
    if (message.keySetModeToVoiceActivity !== undefined) {
      obj.keySetModeToVoiceActivity = HotkeyV3.toJSON(message.keySetModeToVoiceActivity);
    }
    if (message.keySetModeToTap !== undefined) {
      obj.keySetModeToTap = HotkeyV3.toJSON(message.keySetModeToTap);
    }
    if (message.keySetModeToManual !== undefined) {
      obj.keySetModeToManual = HotkeyV3.toJSON(message.keySetModeToManual);
    }
    if (message.keySetModeToTapOpenMicToPtt !== undefined) {
      obj.keySetModeToTapOpenMicToPtt = HotkeyV3.toJSON(message.keySetModeToTapOpenMicToPtt);
    }
    if (message.keySetModeToManualOpenMicToPtt !== undefined) {
      obj.keySetModeToManualOpenMicToPtt = HotkeyV3.toJSON(message.keySetModeToManualOpenMicToPtt);
    }
    if (message.keySwapModeBetweenManualAndVoiceActivity !== undefined) {
      obj.keySwapModeBetweenManualAndVoiceActivity = HotkeyV3.toJSON(message.keySwapModeBetweenManualAndVoiceActivity);
    }
    if (message.keySwapModeBetweenManualAndTap !== undefined) {
      obj.keySwapModeBetweenManualAndTap = HotkeyV3.toJSON(message.keySwapModeBetweenManualAndTap);
    }
    if (message.keySwapModeBetweenManualAndManualOpenMicToPtt !== undefined) {
      obj.keySwapModeBetweenManualAndManualOpenMicToPtt = HotkeyV3.toJSON(
        message.keySwapModeBetweenManualAndManualOpenMicToPtt,
      );
    }
    if (message.keyToggleMuteGlobal !== undefined) {
      obj.keyToggleMuteGlobal = HotkeyV3.toJSON(message.keyToggleMuteGlobal);
    }
    if (message.openMicToPttConsumeInput !== false) {
      obj.openMicToPttConsumeInput = message.openMicToPttConsumeInput;
    }
    if (message.overlayEnable !== false) {
      obj.overlayEnable = message.overlayEnable;
    }
    if (message.overlaySettings !== undefined) {
      obj.overlaySettings = OverlaySettings.toJSON(message.overlaySettings);
    }
    if (message.deviceDisplayName !== "") {
      obj.deviceDisplayName = message.deviceDisplayName;
    }
    if (message.keyGroups?.length) {
      obj.keyGroups = message.keyGroups.map((e) => HotkeyGroup.toJSON(e));
    }
    if (message.useTapActivationWindow !== false) {
      obj.useTapActivationWindow = message.useTapActivationWindow;
    }
    if (message.tapActivationWindowMs !== 0) {
      obj.tapActivationWindowMs = Math.round(message.tapActivationWindowMs);
    }
    if (message.deviceName !== "") {
      obj.deviceName = message.deviceName;
    }
    if (message.deviceUuid !== "") {
      obj.deviceUuid = message.deviceUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileSettings>, I>>(base?: I): ProfileSettings {
    return ProfileSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileSettings>, I>>(object: I): ProfileSettings {
    const message = createBaseProfileSettings();
    message.threshold = object.threshold ?? 0;
    message.useDeactThreshold = object.useDeactThreshold ?? false;
    message.deactThreshold = object.deactThreshold ?? 0;
    message.safe = object.safe ?? false;
    message.safeIntervalMs = object.safeIntervalMs ?? 0;
    message.releaseDelayMs = object.releaseDelayMs ?? 0;
    message.activationMode = object.activationMode ?? 0;
    message.meterType = object.meterType ?? 0;
    message.soundOnPttDown = (object.soundOnPttDown !== undefined && object.soundOnPttDown !== null)
      ? Sound.fromPartial(object.soundOnPttDown)
      : undefined;
    message.soundOnPttUp = (object.soundOnPttUp !== undefined && object.soundOnPttUp !== null)
      ? Sound.fromPartial(object.soundOnPttUp)
      : undefined;
    message.soundOnPushToMuteDown =
      (object.soundOnPushToMuteDown !== undefined && object.soundOnPushToMuteDown !== null)
        ? Sound.fromPartial(object.soundOnPushToMuteDown)
        : undefined;
    message.soundOnPushToMuteUp = (object.soundOnPushToMuteUp !== undefined && object.soundOnPushToMuteUp !== null)
      ? Sound.fromPartial(object.soundOnPushToMuteUp)
      : undefined;
    message.soundOnPushToMuteGlobalDown =
      (object.soundOnPushToMuteGlobalDown !== undefined && object.soundOnPushToMuteGlobalDown !== null)
        ? Sound.fromPartial(object.soundOnPushToMuteGlobalDown)
        : undefined;
    message.soundOnPushToMuteGlobalUp =
      (object.soundOnPushToMuteGlobalUp !== undefined && object.soundOnPushToMuteGlobalUp !== null)
        ? Sound.fromPartial(object.soundOnPushToMuteGlobalUp)
        : undefined;
    message.soundOnSetModeToVoiceActivity =
      (object.soundOnSetModeToVoiceActivity !== undefined && object.soundOnSetModeToVoiceActivity !== null)
        ? Sound.fromPartial(object.soundOnSetModeToVoiceActivity)
        : undefined;
    message.soundOnSetModeToTap = (object.soundOnSetModeToTap !== undefined && object.soundOnSetModeToTap !== null)
      ? Sound.fromPartial(object.soundOnSetModeToTap)
      : undefined;
    message.soundOnSetModeToManual =
      (object.soundOnSetModeToManual !== undefined && object.soundOnSetModeToManual !== null)
        ? Sound.fromPartial(object.soundOnSetModeToManual)
        : undefined;
    message.soundOnSetModeToTapOpenMicToPtt =
      (object.soundOnSetModeToTapOpenMicToPtt !== undefined && object.soundOnSetModeToTapOpenMicToPtt !== null)
        ? Sound.fromPartial(object.soundOnSetModeToTapOpenMicToPtt)
        : undefined;
    message.soundOnSetModeToManualOpenMicToPtt =
      (object.soundOnSetModeToManualOpenMicToPtt !== undefined && object.soundOnSetModeToManualOpenMicToPtt !== null)
        ? Sound.fromPartial(object.soundOnSetModeToManualOpenMicToPtt)
        : undefined;
    message.soundOnToggleMuteGlobalOn =
      (object.soundOnToggleMuteGlobalOn !== undefined && object.soundOnToggleMuteGlobalOn !== null)
        ? Sound.fromPartial(object.soundOnToggleMuteGlobalOn)
        : undefined;
    message.soundOnToggleMuteGlobalOff =
      (object.soundOnToggleMuteGlobalOff !== undefined && object.soundOnToggleMuteGlobalOff !== null)
        ? Sound.fromPartial(object.soundOnToggleMuteGlobalOff)
        : undefined;
    message.soundOnToggleMuteOn = (object.soundOnToggleMuteOn !== undefined && object.soundOnToggleMuteOn !== null)
      ? Sound.fromPartial(object.soundOnToggleMuteOn)
      : undefined;
    message.soundOnToggleMuteOff = (object.soundOnToggleMuteOff !== undefined && object.soundOnToggleMuteOff !== null)
      ? Sound.fromPartial(object.soundOnToggleMuteOff)
      : undefined;
    message.keyPushToMuteGlobal = (object.keyPushToMuteGlobal !== undefined && object.keyPushToMuteGlobal !== null)
      ? HotkeyV3.fromPartial(object.keyPushToMuteGlobal)
      : undefined;
    message.keySetModeToVoiceActivity =
      (object.keySetModeToVoiceActivity !== undefined && object.keySetModeToVoiceActivity !== null)
        ? HotkeyV3.fromPartial(object.keySetModeToVoiceActivity)
        : undefined;
    message.keySetModeToTap = (object.keySetModeToTap !== undefined && object.keySetModeToTap !== null)
      ? HotkeyV3.fromPartial(object.keySetModeToTap)
      : undefined;
    message.keySetModeToManual = (object.keySetModeToManual !== undefined && object.keySetModeToManual !== null)
      ? HotkeyV3.fromPartial(object.keySetModeToManual)
      : undefined;
    message.keySetModeToTapOpenMicToPtt =
      (object.keySetModeToTapOpenMicToPtt !== undefined && object.keySetModeToTapOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.keySetModeToTapOpenMicToPtt)
        : undefined;
    message.keySetModeToManualOpenMicToPtt =
      (object.keySetModeToManualOpenMicToPtt !== undefined && object.keySetModeToManualOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.keySetModeToManualOpenMicToPtt)
        : undefined;
    message.keySwapModeBetweenManualAndVoiceActivity =
      (object.keySwapModeBetweenManualAndVoiceActivity !== undefined &&
          object.keySwapModeBetweenManualAndVoiceActivity !== null)
        ? HotkeyV3.fromPartial(object.keySwapModeBetweenManualAndVoiceActivity)
        : undefined;
    message.keySwapModeBetweenManualAndTap =
      (object.keySwapModeBetweenManualAndTap !== undefined && object.keySwapModeBetweenManualAndTap !== null)
        ? HotkeyV3.fromPartial(object.keySwapModeBetweenManualAndTap)
        : undefined;
    message.keySwapModeBetweenManualAndManualOpenMicToPtt =
      (object.keySwapModeBetweenManualAndManualOpenMicToPtt !== undefined &&
          object.keySwapModeBetweenManualAndManualOpenMicToPtt !== null)
        ? HotkeyV3.fromPartial(object.keySwapModeBetweenManualAndManualOpenMicToPtt)
        : undefined;
    message.keyToggleMuteGlobal = (object.keyToggleMuteGlobal !== undefined && object.keyToggleMuteGlobal !== null)
      ? HotkeyV3.fromPartial(object.keyToggleMuteGlobal)
      : undefined;
    message.openMicToPttConsumeInput = object.openMicToPttConsumeInput ?? false;
    message.overlayEnable = object.overlayEnable ?? false;
    message.overlaySettings = (object.overlaySettings !== undefined && object.overlaySettings !== null)
      ? OverlaySettings.fromPartial(object.overlaySettings)
      : undefined;
    message.deviceDisplayName = object.deviceDisplayName ?? "";
    message.keyGroups = object.keyGroups?.map((e) => HotkeyGroup.fromPartial(e)) || [];
    message.useTapActivationWindow = object.useTapActivationWindow ?? false;
    message.tapActivationWindowMs = object.tapActivationWindowMs ?? 0;
    message.deviceName = object.deviceName ?? "";
    message.deviceUuid = object.deviceUuid ?? "";
    return message;
  },
};

function createBaseProfileActivationTrigger(): ProfileActivationTrigger {
  return { type: 0, text: "", activeWindowOnly: false };
}

export const ProfileActivationTrigger: MessageFns<ProfileActivationTrigger> = {
  encode(message: ProfileActivationTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.activeWindowOnly !== false) {
      writer.uint32(24).bool(message.activeWindowOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProfileActivationTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileActivationTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeWindowOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProfileActivationTrigger {
    return {
      type: isSet(object.type) ? profileActivationTrigger_TextTypeFromJSON(object.type) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      activeWindowOnly: isSet(object.activeWindowOnly) ? globalThis.Boolean(object.activeWindowOnly) : false,
    };
  },

  toJSON(message: ProfileActivationTrigger): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = profileActivationTrigger_TextTypeToJSON(message.type);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.activeWindowOnly !== false) {
      obj.activeWindowOnly = message.activeWindowOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProfileActivationTrigger>, I>>(base?: I): ProfileActivationTrigger {
    return ProfileActivationTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProfileActivationTrigger>, I>>(object: I): ProfileActivationTrigger {
    const message = createBaseProfileActivationTrigger();
    message.type = object.type ?? 0;
    message.text = object.text ?? "";
    message.activeWindowOnly = object.activeWindowOnly ?? false;
    return message;
  },
};

function createBaseSound(): Sound {
  return { enabled: false, file: "", volume: 0 };
}

export const Sound: MessageFns<Sound> = {
  encode(message: Sound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.file !== "") {
      writer.uint32(18).string(message.file);
    }
    if (message.volume !== 0) {
      writer.uint32(25).double(message.volume);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.file = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.volume = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sound {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0,
    };
  },

  toJSON(message: Sound): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (message.volume !== 0) {
      obj.volume = message.volume;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Sound>, I>>(base?: I): Sound {
    return Sound.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Sound>, I>>(object: I): Sound {
    const message = createBaseSound();
    message.enabled = object.enabled ?? false;
    message.file = object.file ?? "";
    message.volume = object.volume ?? 0;
    return message;
  },
};

function createBaseHotkeyV3(): HotkeyV3 {
  return { vkCodes: [], joyButtons: [], joyPovs: [] };
}

export const HotkeyV3: MessageFns<HotkeyV3> = {
  encode(message: HotkeyV3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.vkCodes) {
      writer.uint32(v);
    }
    writer.join();
    for (const v of message.joyButtons) {
      JoyButton.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.joyPovs) {
      JoyPov.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotkeyV3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotkeyV3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.vkCodes.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vkCodes.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.joyButtons.push(JoyButton.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.joyPovs.push(JoyPov.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotkeyV3 {
    return {
      vkCodes: globalThis.Array.isArray(object?.vkCodes) ? object.vkCodes.map((e: any) => globalThis.Number(e)) : [],
      joyButtons: globalThis.Array.isArray(object?.joyButtons)
        ? object.joyButtons.map((e: any) => JoyButton.fromJSON(e))
        : [],
      joyPovs: globalThis.Array.isArray(object?.joyPovs) ? object.joyPovs.map((e: any) => JoyPov.fromJSON(e)) : [],
    };
  },

  toJSON(message: HotkeyV3): unknown {
    const obj: any = {};
    if (message.vkCodes?.length) {
      obj.vkCodes = message.vkCodes.map((e) => Math.round(e));
    }
    if (message.joyButtons?.length) {
      obj.joyButtons = message.joyButtons.map((e) => JoyButton.toJSON(e));
    }
    if (message.joyPovs?.length) {
      obj.joyPovs = message.joyPovs.map((e) => JoyPov.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HotkeyV3>, I>>(base?: I): HotkeyV3 {
    return HotkeyV3.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HotkeyV3>, I>>(object: I): HotkeyV3 {
    const message = createBaseHotkeyV3();
    message.vkCodes = object.vkCodes?.map((e) => e) || [];
    message.joyButtons = object.joyButtons?.map((e) => JoyButton.fromPartial(e)) || [];
    message.joyPovs = object.joyPovs?.map((e) => JoyPov.fromPartial(e)) || [];
    return message;
  },
};

function createBaseJoyButton(): JoyButton {
  return { joyId: undefined, button: 0 };
}

export const JoyButton: MessageFns<JoyButton> = {
  encode(message: JoyButton, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joyId !== undefined) {
      JoyId.encode(message.joyId, writer.uint32(10).fork()).join();
    }
    if (message.button !== 0) {
      writer.uint32(24).uint32(message.button);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoyButton {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoyButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.joyId = JoyId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.button = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoyButton {
    return {
      joyId: isSet(object.joyId) ? JoyId.fromJSON(object.joyId) : undefined,
      button: isSet(object.button) ? globalThis.Number(object.button) : 0,
    };
  },

  toJSON(message: JoyButton): unknown {
    const obj: any = {};
    if (message.joyId !== undefined) {
      obj.joyId = JoyId.toJSON(message.joyId);
    }
    if (message.button !== 0) {
      obj.button = Math.round(message.button);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoyButton>, I>>(base?: I): JoyButton {
    return JoyButton.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoyButton>, I>>(object: I): JoyButton {
    const message = createBaseJoyButton();
    message.joyId = (object.joyId !== undefined && object.joyId !== null) ? JoyId.fromPartial(object.joyId) : undefined;
    message.button = object.button ?? 0;
    return message;
  },
};

function createBaseJoyPov(): JoyPov {
  return { joyId: undefined, index: 0, direction: 0 };
}

export const JoyPov: MessageFns<JoyPov> = {
  encode(message: JoyPov, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joyId !== undefined) {
      JoyId.encode(message.joyId, writer.uint32(10).fork()).join();
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.direction !== 0) {
      writer.uint32(24).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoyPov {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoyPov();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.joyId = JoyId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoyPov {
    return {
      joyId: isSet(object.joyId) ? JoyId.fromJSON(object.joyId) : undefined,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      direction: isSet(object.direction) ? joyPovDirectionFromJSON(object.direction) : 0,
    };
  },

  toJSON(message: JoyPov): unknown {
    const obj: any = {};
    if (message.joyId !== undefined) {
      obj.joyId = JoyId.toJSON(message.joyId);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.direction !== 0) {
      obj.direction = joyPovDirectionToJSON(message.direction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoyPov>, I>>(base?: I): JoyPov {
    return JoyPov.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoyPov>, I>>(object: I): JoyPov {
    const message = createBaseJoyPov();
    message.joyId = (object.joyId !== undefined && object.joyId !== null) ? JoyId.fromPartial(object.joyId) : undefined;
    message.index = object.index ?? 0;
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseJoyId(): JoyId {
  return { guid: new Uint8Array(0), name: "" };
}

export const JoyId: MessageFns<JoyId> = {
  encode(message: JoyId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guid.length !== 0) {
      writer.uint32(10).bytes(message.guid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoyId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoyId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.guid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoyId {
    return {
      guid: isSet(object.guid) ? bytesFromBase64(object.guid) : new Uint8Array(0),
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: JoyId): unknown {
    const obj: any = {};
    if (message.guid.length !== 0) {
      obj.guid = base64FromBytes(message.guid);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoyId>, I>>(base?: I): JoyId {
    return JoyId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoyId>, I>>(object: I): JoyId {
    const message = createBaseJoyId();
    message.guid = object.guid ?? new Uint8Array(0);
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseHotkeyGroup(): HotkeyGroup {
  return { displayName: "", pushToTalk: undefined, pushToMute: [], extraTriggers: [], toggleMute: [] };
}

export const HotkeyGroup: MessageFns<HotkeyGroup> = {
  encode(message: HotkeyGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.pushToTalk !== undefined) {
      HotkeyV3.encode(message.pushToTalk, writer.uint32(18).fork()).join();
    }
    for (const v of message.pushToMute) {
      HotkeyV3.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.extraTriggers) {
      HotkeyV3.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.toggleMute) {
      HotkeyV3.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HotkeyGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHotkeyGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pushToTalk = HotkeyV3.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pushToMute.push(HotkeyV3.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.extraTriggers.push(HotkeyV3.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toggleMute.push(HotkeyV3.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HotkeyGroup {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      pushToTalk: isSet(object.pushToTalk) ? HotkeyV3.fromJSON(object.pushToTalk) : undefined,
      pushToMute: globalThis.Array.isArray(object?.pushToMute)
        ? object.pushToMute.map((e: any) => HotkeyV3.fromJSON(e))
        : [],
      extraTriggers: globalThis.Array.isArray(object?.extraTriggers)
        ? object.extraTriggers.map((e: any) => HotkeyV3.fromJSON(e))
        : [],
      toggleMute: globalThis.Array.isArray(object?.toggleMute)
        ? object.toggleMute.map((e: any) => HotkeyV3.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HotkeyGroup): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.pushToTalk !== undefined) {
      obj.pushToTalk = HotkeyV3.toJSON(message.pushToTalk);
    }
    if (message.pushToMute?.length) {
      obj.pushToMute = message.pushToMute.map((e) => HotkeyV3.toJSON(e));
    }
    if (message.extraTriggers?.length) {
      obj.extraTriggers = message.extraTriggers.map((e) => HotkeyV3.toJSON(e));
    }
    if (message.toggleMute?.length) {
      obj.toggleMute = message.toggleMute.map((e) => HotkeyV3.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HotkeyGroup>, I>>(base?: I): HotkeyGroup {
    return HotkeyGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HotkeyGroup>, I>>(object: I): HotkeyGroup {
    const message = createBaseHotkeyGroup();
    message.displayName = object.displayName ?? "";
    message.pushToTalk = (object.pushToTalk !== undefined && object.pushToTalk !== null)
      ? HotkeyV3.fromPartial(object.pushToTalk)
      : undefined;
    message.pushToMute = object.pushToMute?.map((e) => HotkeyV3.fromPartial(e)) || [];
    message.extraTriggers = object.extraTriggers?.map((e) => HotkeyV3.fromPartial(e)) || [];
    message.toggleMute = object.toggleMute?.map((e) => HotkeyV3.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSelectedTab(): SelectedTab {
  return { settingsGeneral: undefined, settingsDevice: undefined, overview: undefined };
}

export const SelectedTab: MessageFns<SelectedTab> = {
  encode(message: SelectedTab, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settingsGeneral !== undefined) {
      SelectedTabSettingsGeneral.encode(message.settingsGeneral, writer.uint32(10).fork()).join();
    }
    if (message.settingsDevice !== undefined) {
      SelectedTabSettingsDevice.encode(message.settingsDevice, writer.uint32(18).fork()).join();
    }
    if (message.overview !== undefined) {
      SelectedTabOverview.encode(message.overview, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedTab {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedTab();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settingsGeneral = SelectedTabSettingsGeneral.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.settingsDevice = SelectedTabSettingsDevice.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.overview = SelectedTabOverview.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectedTab {
    return {
      settingsGeneral: isSet(object.settingsGeneral)
        ? SelectedTabSettingsGeneral.fromJSON(object.settingsGeneral)
        : undefined,
      settingsDevice: isSet(object.settingsDevice)
        ? SelectedTabSettingsDevice.fromJSON(object.settingsDevice)
        : undefined,
      overview: isSet(object.overview) ? SelectedTabOverview.fromJSON(object.overview) : undefined,
    };
  },

  toJSON(message: SelectedTab): unknown {
    const obj: any = {};
    if (message.settingsGeneral !== undefined) {
      obj.settingsGeneral = SelectedTabSettingsGeneral.toJSON(message.settingsGeneral);
    }
    if (message.settingsDevice !== undefined) {
      obj.settingsDevice = SelectedTabSettingsDevice.toJSON(message.settingsDevice);
    }
    if (message.overview !== undefined) {
      obj.overview = SelectedTabOverview.toJSON(message.overview);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectedTab>, I>>(base?: I): SelectedTab {
    return SelectedTab.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectedTab>, I>>(object: I): SelectedTab {
    const message = createBaseSelectedTab();
    message.settingsGeneral = (object.settingsGeneral !== undefined && object.settingsGeneral !== null)
      ? SelectedTabSettingsGeneral.fromPartial(object.settingsGeneral)
      : undefined;
    message.settingsDevice = (object.settingsDevice !== undefined && object.settingsDevice !== null)
      ? SelectedTabSettingsDevice.fromPartial(object.settingsDevice)
      : undefined;
    message.overview = (object.overview !== undefined && object.overview !== null)
      ? SelectedTabOverview.fromPartial(object.overview)
      : undefined;
    return message;
  },
};

function createBaseSelectedTabOverview(): SelectedTabOverview {
  return {};
}

export const SelectedTabOverview: MessageFns<SelectedTabOverview> = {
  encode(_: SelectedTabOverview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedTabOverview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedTabOverview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SelectedTabOverview {
    return {};
  },

  toJSON(_: SelectedTabOverview): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectedTabOverview>, I>>(base?: I): SelectedTabOverview {
    return SelectedTabOverview.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectedTabOverview>, I>>(_: I): SelectedTabOverview {
    const message = createBaseSelectedTabOverview();
    return message;
  },
};

function createBaseSelectedTabSettingsGeneral(): SelectedTabSettingsGeneral {
  return {};
}

export const SelectedTabSettingsGeneral: MessageFns<SelectedTabSettingsGeneral> = {
  encode(_: SelectedTabSettingsGeneral, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedTabSettingsGeneral {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedTabSettingsGeneral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SelectedTabSettingsGeneral {
    return {};
  },

  toJSON(_: SelectedTabSettingsGeneral): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectedTabSettingsGeneral>, I>>(base?: I): SelectedTabSettingsGeneral {
    return SelectedTabSettingsGeneral.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectedTabSettingsGeneral>, I>>(_: I): SelectedTabSettingsGeneral {
    const message = createBaseSelectedTabSettingsGeneral();
    return message;
  },
};

function createBaseSelectedTabSettingsDevice(): SelectedTabSettingsDevice {
  return { deviceIndex: 0 };
}

export const SelectedTabSettingsDevice: MessageFns<SelectedTabSettingsDevice> = {
  encode(message: SelectedTabSettingsDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceIndex !== 0) {
      writer.uint32(8).int32(message.deviceIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelectedTabSettingsDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelectedTabSettingsDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deviceIndex = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelectedTabSettingsDevice {
    return { deviceIndex: isSet(object.deviceIndex) ? globalThis.Number(object.deviceIndex) : 0 };
  },

  toJSON(message: SelectedTabSettingsDevice): unknown {
    const obj: any = {};
    if (message.deviceIndex !== 0) {
      obj.deviceIndex = Math.round(message.deviceIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelectedTabSettingsDevice>, I>>(base?: I): SelectedTabSettingsDevice {
    return SelectedTabSettingsDevice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelectedTabSettingsDevice>, I>>(object: I): SelectedTabSettingsDevice {
    const message = createBaseSelectedTabSettingsDevice();
    message.deviceIndex = object.deviceIndex ?? 0;
    return message;
  },
};

function createBaseIpc(): Ipc {
  return {
    serverHello: undefined,
    activityStateChanged: undefined,
    appEnabledStateChanged: undefined,
    currentValueChanged: undefined,
    muteStateChanged: undefined,
    settingsChanged: undefined,
    toggleMuteGlobalChanged: undefined,
    toggleMuteChanged: undefined,
    sidekickConnected: undefined,
    sidekickDisconnected: undefined,
    updaterStateChanged: undefined,
    updateCheckSuccess: undefined,
    updateCheckFailed: undefined,
    guiDeviceChanged: undefined,
    overlayHello: undefined,
    clientConfigure: undefined,
    requestRestart: undefined,
    requestExit: undefined,
    requestUpdate: undefined,
    requestUpdateSettings: undefined,
    requestPlaySfx: undefined,
    requestSwapActivationMode: undefined,
    requestSetPushToTalkState: undefined,
    requestSetPushToMuteState: undefined,
    requestSetPushToMuteGlobalState: undefined,
    requestToggleMuteGlobal: undefined,
    requestToggleMute: undefined,
  };
}

export const Ipc: MessageFns<Ipc> = {
  encode(message: Ipc, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverHello !== undefined) {
      IpcServerHello.encode(message.serverHello, writer.uint32(186).fork()).join();
    }
    if (message.activityStateChanged !== undefined) {
      IpcActivityStateChanged.encode(message.activityStateChanged, writer.uint32(10).fork()).join();
    }
    if (message.appEnabledStateChanged !== undefined) {
      IpcAppEnabledStateChanged.encode(message.appEnabledStateChanged, writer.uint32(202).fork()).join();
    }
    if (message.currentValueChanged !== undefined) {
      IpcCurrentValueChanged.encode(message.currentValueChanged, writer.uint32(146).fork()).join();
    }
    if (message.muteStateChanged !== undefined) {
      IpcMuteStateChanged.encode(message.muteStateChanged, writer.uint32(18).fork()).join();
    }
    if (message.settingsChanged !== undefined) {
      IpcSettingsChanged.encode(message.settingsChanged, writer.uint32(26).fork()).join();
    }
    if (message.toggleMuteGlobalChanged !== undefined) {
      IpcToggleMuteGlobalChanged.encode(message.toggleMuteGlobalChanged, writer.uint32(250).fork()).join();
    }
    if (message.toggleMuteChanged !== undefined) {
      IpcToggleMuteChanged.encode(message.toggleMuteChanged, writer.uint32(258).fork()).join();
    }
    if (message.sidekickConnected !== undefined) {
      IpcSidekickConnected.encode(message.sidekickConnected, writer.uint32(58).fork()).join();
    }
    if (message.sidekickDisconnected !== undefined) {
      IpcSidekickDisconnected.encode(message.sidekickDisconnected, writer.uint32(66).fork()).join();
    }
    if (message.updaterStateChanged !== undefined) {
      IpcUpdaterStateChanged.encode(message.updaterStateChanged, writer.uint32(114).fork()).join();
    }
    if (message.updateCheckSuccess !== undefined) {
      IpcUpdateCheckSuccess.encode(message.updateCheckSuccess, writer.uint32(122).fork()).join();
    }
    if (message.updateCheckFailed !== undefined) {
      IpcUpdateCheckFailed.encode(message.updateCheckFailed, writer.uint32(130).fork()).join();
    }
    if (message.guiDeviceChanged !== undefined) {
      IpcGuiDeviceChanged.encode(message.guiDeviceChanged, writer.uint32(194).fork()).join();
    }
    if (message.overlayHello !== undefined) {
      IpcOverlayHello.encode(message.overlayHello, writer.uint32(34).fork()).join();
    }
    if (message.clientConfigure !== undefined) {
      IpcClientConfigure.encode(message.clientConfigure, writer.uint32(178).fork()).join();
    }
    if (message.requestRestart !== undefined) {
      IpcRequestRestart.encode(message.requestRestart, writer.uint32(82).fork()).join();
    }
    if (message.requestExit !== undefined) {
      IpcRequestExit.encode(message.requestExit, writer.uint32(90).fork()).join();
    }
    if (message.requestUpdate !== undefined) {
      IpcRequestUpdate.encode(message.requestUpdate, writer.uint32(98).fork()).join();
    }
    if (message.requestUpdateSettings !== undefined) {
      IpcRequestUpdateSettings.encode(message.requestUpdateSettings, writer.uint32(106).fork()).join();
    }
    if (message.requestPlaySfx !== undefined) {
      IpcRequestPlaySfx.encode(message.requestPlaySfx, writer.uint32(170).fork()).join();
    }
    if (message.requestSwapActivationMode !== undefined) {
      IpcRequestSwapActivationMode.encode(message.requestSwapActivationMode, writer.uint32(210).fork()).join();
    }
    if (message.requestSetPushToTalkState !== undefined) {
      IpcRequestSetPushToTalkState.encode(message.requestSetPushToTalkState, writer.uint32(218).fork()).join();
    }
    if (message.requestSetPushToMuteState !== undefined) {
      IpcRequestSetPushToMuteState.encode(message.requestSetPushToMuteState, writer.uint32(226).fork()).join();
    }
    if (message.requestSetPushToMuteGlobalState !== undefined) {
      IpcRequestSetPushToMuteGlobalState.encode(message.requestSetPushToMuteGlobalState, writer.uint32(234).fork())
        .join();
    }
    if (message.requestToggleMuteGlobal !== undefined) {
      IpcRequestToggleMuteGlobal.encode(message.requestToggleMuteGlobal, writer.uint32(242).fork()).join();
    }
    if (message.requestToggleMute !== undefined) {
      IpcRequestToggleMute.encode(message.requestToggleMute, writer.uint32(266).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ipc {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.serverHello = IpcServerHello.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.activityStateChanged = IpcActivityStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.appEnabledStateChanged = IpcAppEnabledStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.currentValueChanged = IpcCurrentValueChanged.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.muteStateChanged = IpcMuteStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.settingsChanged = IpcSettingsChanged.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.toggleMuteGlobalChanged = IpcToggleMuteGlobalChanged.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.toggleMuteChanged = IpcToggleMuteChanged.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sidekickConnected = IpcSidekickConnected.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sidekickDisconnected = IpcSidekickDisconnected.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updaterStateChanged = IpcUpdaterStateChanged.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updateCheckSuccess = IpcUpdateCheckSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updateCheckFailed = IpcUpdateCheckFailed.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.guiDeviceChanged = IpcGuiDeviceChanged.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.overlayHello = IpcOverlayHello.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.clientConfigure = IpcClientConfigure.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requestRestart = IpcRequestRestart.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.requestExit = IpcRequestExit.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.requestUpdate = IpcRequestUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.requestUpdateSettings = IpcRequestUpdateSettings.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.requestPlaySfx = IpcRequestPlaySfx.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.requestSwapActivationMode = IpcRequestSwapActivationMode.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.requestSetPushToTalkState = IpcRequestSetPushToTalkState.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.requestSetPushToMuteState = IpcRequestSetPushToMuteState.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.requestSetPushToMuteGlobalState = IpcRequestSetPushToMuteGlobalState.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.requestToggleMuteGlobal = IpcRequestToggleMuteGlobal.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.requestToggleMute = IpcRequestToggleMute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ipc {
    return {
      serverHello: isSet(object.serverHello) ? IpcServerHello.fromJSON(object.serverHello) : undefined,
      activityStateChanged: isSet(object.activityStateChanged)
        ? IpcActivityStateChanged.fromJSON(object.activityStateChanged)
        : undefined,
      appEnabledStateChanged: isSet(object.appEnabledStateChanged)
        ? IpcAppEnabledStateChanged.fromJSON(object.appEnabledStateChanged)
        : undefined,
      currentValueChanged: isSet(object.currentValueChanged)
        ? IpcCurrentValueChanged.fromJSON(object.currentValueChanged)
        : undefined,
      muteStateChanged: isSet(object.muteStateChanged)
        ? IpcMuteStateChanged.fromJSON(object.muteStateChanged)
        : undefined,
      settingsChanged: isSet(object.settingsChanged) ? IpcSettingsChanged.fromJSON(object.settingsChanged) : undefined,
      toggleMuteGlobalChanged: isSet(object.toggleMuteGlobalChanged)
        ? IpcToggleMuteGlobalChanged.fromJSON(object.toggleMuteGlobalChanged)
        : undefined,
      toggleMuteChanged: isSet(object.toggleMuteChanged)
        ? IpcToggleMuteChanged.fromJSON(object.toggleMuteChanged)
        : undefined,
      sidekickConnected: isSet(object.sidekickConnected)
        ? IpcSidekickConnected.fromJSON(object.sidekickConnected)
        : undefined,
      sidekickDisconnected: isSet(object.sidekickDisconnected)
        ? IpcSidekickDisconnected.fromJSON(object.sidekickDisconnected)
        : undefined,
      updaterStateChanged: isSet(object.updaterStateChanged)
        ? IpcUpdaterStateChanged.fromJSON(object.updaterStateChanged)
        : undefined,
      updateCheckSuccess: isSet(object.updateCheckSuccess)
        ? IpcUpdateCheckSuccess.fromJSON(object.updateCheckSuccess)
        : undefined,
      updateCheckFailed: isSet(object.updateCheckFailed)
        ? IpcUpdateCheckFailed.fromJSON(object.updateCheckFailed)
        : undefined,
      guiDeviceChanged: isSet(object.guiDeviceChanged)
        ? IpcGuiDeviceChanged.fromJSON(object.guiDeviceChanged)
        : undefined,
      overlayHello: isSet(object.overlayHello) ? IpcOverlayHello.fromJSON(object.overlayHello) : undefined,
      clientConfigure: isSet(object.clientConfigure) ? IpcClientConfigure.fromJSON(object.clientConfigure) : undefined,
      requestRestart: isSet(object.requestRestart) ? IpcRequestRestart.fromJSON(object.requestRestart) : undefined,
      requestExit: isSet(object.requestExit) ? IpcRequestExit.fromJSON(object.requestExit) : undefined,
      requestUpdate: isSet(object.requestUpdate) ? IpcRequestUpdate.fromJSON(object.requestUpdate) : undefined,
      requestUpdateSettings: isSet(object.requestUpdateSettings)
        ? IpcRequestUpdateSettings.fromJSON(object.requestUpdateSettings)
        : undefined,
      requestPlaySfx: isSet(object.requestPlaySfx) ? IpcRequestPlaySfx.fromJSON(object.requestPlaySfx) : undefined,
      requestSwapActivationMode: isSet(object.requestSwapActivationMode)
        ? IpcRequestSwapActivationMode.fromJSON(object.requestSwapActivationMode)
        : undefined,
      requestSetPushToTalkState: isSet(object.requestSetPushToTalkState)
        ? IpcRequestSetPushToTalkState.fromJSON(object.requestSetPushToTalkState)
        : undefined,
      requestSetPushToMuteState: isSet(object.requestSetPushToMuteState)
        ? IpcRequestSetPushToMuteState.fromJSON(object.requestSetPushToMuteState)
        : undefined,
      requestSetPushToMuteGlobalState: isSet(object.requestSetPushToMuteGlobalState)
        ? IpcRequestSetPushToMuteGlobalState.fromJSON(object.requestSetPushToMuteGlobalState)
        : undefined,
      requestToggleMuteGlobal: isSet(object.requestToggleMuteGlobal)
        ? IpcRequestToggleMuteGlobal.fromJSON(object.requestToggleMuteGlobal)
        : undefined,
      requestToggleMute: isSet(object.requestToggleMute)
        ? IpcRequestToggleMute.fromJSON(object.requestToggleMute)
        : undefined,
    };
  },

  toJSON(message: Ipc): unknown {
    const obj: any = {};
    if (message.serverHello !== undefined) {
      obj.serverHello = IpcServerHello.toJSON(message.serverHello);
    }
    if (message.activityStateChanged !== undefined) {
      obj.activityStateChanged = IpcActivityStateChanged.toJSON(message.activityStateChanged);
    }
    if (message.appEnabledStateChanged !== undefined) {
      obj.appEnabledStateChanged = IpcAppEnabledStateChanged.toJSON(message.appEnabledStateChanged);
    }
    if (message.currentValueChanged !== undefined) {
      obj.currentValueChanged = IpcCurrentValueChanged.toJSON(message.currentValueChanged);
    }
    if (message.muteStateChanged !== undefined) {
      obj.muteStateChanged = IpcMuteStateChanged.toJSON(message.muteStateChanged);
    }
    if (message.settingsChanged !== undefined) {
      obj.settingsChanged = IpcSettingsChanged.toJSON(message.settingsChanged);
    }
    if (message.toggleMuteGlobalChanged !== undefined) {
      obj.toggleMuteGlobalChanged = IpcToggleMuteGlobalChanged.toJSON(message.toggleMuteGlobalChanged);
    }
    if (message.toggleMuteChanged !== undefined) {
      obj.toggleMuteChanged = IpcToggleMuteChanged.toJSON(message.toggleMuteChanged);
    }
    if (message.sidekickConnected !== undefined) {
      obj.sidekickConnected = IpcSidekickConnected.toJSON(message.sidekickConnected);
    }
    if (message.sidekickDisconnected !== undefined) {
      obj.sidekickDisconnected = IpcSidekickDisconnected.toJSON(message.sidekickDisconnected);
    }
    if (message.updaterStateChanged !== undefined) {
      obj.updaterStateChanged = IpcUpdaterStateChanged.toJSON(message.updaterStateChanged);
    }
    if (message.updateCheckSuccess !== undefined) {
      obj.updateCheckSuccess = IpcUpdateCheckSuccess.toJSON(message.updateCheckSuccess);
    }
    if (message.updateCheckFailed !== undefined) {
      obj.updateCheckFailed = IpcUpdateCheckFailed.toJSON(message.updateCheckFailed);
    }
    if (message.guiDeviceChanged !== undefined) {
      obj.guiDeviceChanged = IpcGuiDeviceChanged.toJSON(message.guiDeviceChanged);
    }
    if (message.overlayHello !== undefined) {
      obj.overlayHello = IpcOverlayHello.toJSON(message.overlayHello);
    }
    if (message.clientConfigure !== undefined) {
      obj.clientConfigure = IpcClientConfigure.toJSON(message.clientConfigure);
    }
    if (message.requestRestart !== undefined) {
      obj.requestRestart = IpcRequestRestart.toJSON(message.requestRestart);
    }
    if (message.requestExit !== undefined) {
      obj.requestExit = IpcRequestExit.toJSON(message.requestExit);
    }
    if (message.requestUpdate !== undefined) {
      obj.requestUpdate = IpcRequestUpdate.toJSON(message.requestUpdate);
    }
    if (message.requestUpdateSettings !== undefined) {
      obj.requestUpdateSettings = IpcRequestUpdateSettings.toJSON(message.requestUpdateSettings);
    }
    if (message.requestPlaySfx !== undefined) {
      obj.requestPlaySfx = IpcRequestPlaySfx.toJSON(message.requestPlaySfx);
    }
    if (message.requestSwapActivationMode !== undefined) {
      obj.requestSwapActivationMode = IpcRequestSwapActivationMode.toJSON(message.requestSwapActivationMode);
    }
    if (message.requestSetPushToTalkState !== undefined) {
      obj.requestSetPushToTalkState = IpcRequestSetPushToTalkState.toJSON(message.requestSetPushToTalkState);
    }
    if (message.requestSetPushToMuteState !== undefined) {
      obj.requestSetPushToMuteState = IpcRequestSetPushToMuteState.toJSON(message.requestSetPushToMuteState);
    }
    if (message.requestSetPushToMuteGlobalState !== undefined) {
      obj.requestSetPushToMuteGlobalState = IpcRequestSetPushToMuteGlobalState.toJSON(
        message.requestSetPushToMuteGlobalState,
      );
    }
    if (message.requestToggleMuteGlobal !== undefined) {
      obj.requestToggleMuteGlobal = IpcRequestToggleMuteGlobal.toJSON(message.requestToggleMuteGlobal);
    }
    if (message.requestToggleMute !== undefined) {
      obj.requestToggleMute = IpcRequestToggleMute.toJSON(message.requestToggleMute);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ipc>, I>>(base?: I): Ipc {
    return Ipc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ipc>, I>>(object: I): Ipc {
    const message = createBaseIpc();
    message.serverHello = (object.serverHello !== undefined && object.serverHello !== null)
      ? IpcServerHello.fromPartial(object.serverHello)
      : undefined;
    message.activityStateChanged = (object.activityStateChanged !== undefined && object.activityStateChanged !== null)
      ? IpcActivityStateChanged.fromPartial(object.activityStateChanged)
      : undefined;
    message.appEnabledStateChanged =
      (object.appEnabledStateChanged !== undefined && object.appEnabledStateChanged !== null)
        ? IpcAppEnabledStateChanged.fromPartial(object.appEnabledStateChanged)
        : undefined;
    message.currentValueChanged = (object.currentValueChanged !== undefined && object.currentValueChanged !== null)
      ? IpcCurrentValueChanged.fromPartial(object.currentValueChanged)
      : undefined;
    message.muteStateChanged = (object.muteStateChanged !== undefined && object.muteStateChanged !== null)
      ? IpcMuteStateChanged.fromPartial(object.muteStateChanged)
      : undefined;
    message.settingsChanged = (object.settingsChanged !== undefined && object.settingsChanged !== null)
      ? IpcSettingsChanged.fromPartial(object.settingsChanged)
      : undefined;
    message.toggleMuteGlobalChanged =
      (object.toggleMuteGlobalChanged !== undefined && object.toggleMuteGlobalChanged !== null)
        ? IpcToggleMuteGlobalChanged.fromPartial(object.toggleMuteGlobalChanged)
        : undefined;
    message.toggleMuteChanged = (object.toggleMuteChanged !== undefined && object.toggleMuteChanged !== null)
      ? IpcToggleMuteChanged.fromPartial(object.toggleMuteChanged)
      : undefined;
    message.sidekickConnected = (object.sidekickConnected !== undefined && object.sidekickConnected !== null)
      ? IpcSidekickConnected.fromPartial(object.sidekickConnected)
      : undefined;
    message.sidekickDisconnected = (object.sidekickDisconnected !== undefined && object.sidekickDisconnected !== null)
      ? IpcSidekickDisconnected.fromPartial(object.sidekickDisconnected)
      : undefined;
    message.updaterStateChanged = (object.updaterStateChanged !== undefined && object.updaterStateChanged !== null)
      ? IpcUpdaterStateChanged.fromPartial(object.updaterStateChanged)
      : undefined;
    message.updateCheckSuccess = (object.updateCheckSuccess !== undefined && object.updateCheckSuccess !== null)
      ? IpcUpdateCheckSuccess.fromPartial(object.updateCheckSuccess)
      : undefined;
    message.updateCheckFailed = (object.updateCheckFailed !== undefined && object.updateCheckFailed !== null)
      ? IpcUpdateCheckFailed.fromPartial(object.updateCheckFailed)
      : undefined;
    message.guiDeviceChanged = (object.guiDeviceChanged !== undefined && object.guiDeviceChanged !== null)
      ? IpcGuiDeviceChanged.fromPartial(object.guiDeviceChanged)
      : undefined;
    message.overlayHello = (object.overlayHello !== undefined && object.overlayHello !== null)
      ? IpcOverlayHello.fromPartial(object.overlayHello)
      : undefined;
    message.clientConfigure = (object.clientConfigure !== undefined && object.clientConfigure !== null)
      ? IpcClientConfigure.fromPartial(object.clientConfigure)
      : undefined;
    message.requestRestart = (object.requestRestart !== undefined && object.requestRestart !== null)
      ? IpcRequestRestart.fromPartial(object.requestRestart)
      : undefined;
    message.requestExit = (object.requestExit !== undefined && object.requestExit !== null)
      ? IpcRequestExit.fromPartial(object.requestExit)
      : undefined;
    message.requestUpdate = (object.requestUpdate !== undefined && object.requestUpdate !== null)
      ? IpcRequestUpdate.fromPartial(object.requestUpdate)
      : undefined;
    message.requestUpdateSettings =
      (object.requestUpdateSettings !== undefined && object.requestUpdateSettings !== null)
        ? IpcRequestUpdateSettings.fromPartial(object.requestUpdateSettings)
        : undefined;
    message.requestPlaySfx = (object.requestPlaySfx !== undefined && object.requestPlaySfx !== null)
      ? IpcRequestPlaySfx.fromPartial(object.requestPlaySfx)
      : undefined;
    message.requestSwapActivationMode =
      (object.requestSwapActivationMode !== undefined && object.requestSwapActivationMode !== null)
        ? IpcRequestSwapActivationMode.fromPartial(object.requestSwapActivationMode)
        : undefined;
    message.requestSetPushToTalkState =
      (object.requestSetPushToTalkState !== undefined && object.requestSetPushToTalkState !== null)
        ? IpcRequestSetPushToTalkState.fromPartial(object.requestSetPushToTalkState)
        : undefined;
    message.requestSetPushToMuteState =
      (object.requestSetPushToMuteState !== undefined && object.requestSetPushToMuteState !== null)
        ? IpcRequestSetPushToMuteState.fromPartial(object.requestSetPushToMuteState)
        : undefined;
    message.requestSetPushToMuteGlobalState =
      (object.requestSetPushToMuteGlobalState !== undefined && object.requestSetPushToMuteGlobalState !== null)
        ? IpcRequestSetPushToMuteGlobalState.fromPartial(object.requestSetPushToMuteGlobalState)
        : undefined;
    message.requestToggleMuteGlobal =
      (object.requestToggleMuteGlobal !== undefined && object.requestToggleMuteGlobal !== null)
        ? IpcRequestToggleMuteGlobal.fromPartial(object.requestToggleMuteGlobal)
        : undefined;
    message.requestToggleMute = (object.requestToggleMute !== undefined && object.requestToggleMute !== null)
      ? IpcRequestToggleMute.fromPartial(object.requestToggleMute)
      : undefined;
    return message;
  },
};

function createBaseIpcActivityStateChanged(): IpcActivityStateChanged {
  return { aggregateState: 0, keyGroupStates: [] };
}

export const IpcActivityStateChanged: MessageFns<IpcActivityStateChanged> = {
  encode(message: IpcActivityStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregateState !== 0) {
      writer.uint32(8).int32(message.aggregateState);
    }
    writer.uint32(18).fork();
    for (const v of message.keyGroupStates) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcActivityStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcActivityStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.aggregateState = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.keyGroupStates.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keyGroupStates.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcActivityStateChanged {
    return {
      aggregateState: isSet(object.aggregateState) ? activityStateFromJSON(object.aggregateState) : 0,
      keyGroupStates: globalThis.Array.isArray(object?.keyGroupStates)
        ? object.keyGroupStates.map((e: any) => activityStateFromJSON(e))
        : [],
    };
  },

  toJSON(message: IpcActivityStateChanged): unknown {
    const obj: any = {};
    if (message.aggregateState !== 0) {
      obj.aggregateState = activityStateToJSON(message.aggregateState);
    }
    if (message.keyGroupStates?.length) {
      obj.keyGroupStates = message.keyGroupStates.map((e) => activityStateToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcActivityStateChanged>, I>>(base?: I): IpcActivityStateChanged {
    return IpcActivityStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcActivityStateChanged>, I>>(object: I): IpcActivityStateChanged {
    const message = createBaseIpcActivityStateChanged();
    message.aggregateState = object.aggregateState ?? 0;
    message.keyGroupStates = object.keyGroupStates?.map((e) => e) || [];
    return message;
  },
};

function createBaseIpcMuteStateChanged(): IpcMuteStateChanged {
  return { isMuted: false };
}

export const IpcMuteStateChanged: MessageFns<IpcMuteStateChanged> = {
  encode(message: IpcMuteStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isMuted !== false) {
      writer.uint32(8).bool(message.isMuted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcMuteStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcMuteStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isMuted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcMuteStateChanged {
    return { isMuted: isSet(object.isMuted) ? globalThis.Boolean(object.isMuted) : false };
  },

  toJSON(message: IpcMuteStateChanged): unknown {
    const obj: any = {};
    if (message.isMuted !== false) {
      obj.isMuted = message.isMuted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcMuteStateChanged>, I>>(base?: I): IpcMuteStateChanged {
    return IpcMuteStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcMuteStateChanged>, I>>(object: I): IpcMuteStateChanged {
    const message = createBaseIpcMuteStateChanged();
    message.isMuted = object.isMuted ?? false;
    return message;
  },
};

function createBaseIpcSettingsChanged(): IpcSettingsChanged {
  return { settings: undefined };
}

export const IpcSettingsChanged: MessageFns<IpcSettingsChanged> = {
  encode(message: IpcSettingsChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcSettingsChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcSettingsChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcSettingsChanged {
    return { settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined };
  },

  toJSON(message: IpcSettingsChanged): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcSettingsChanged>, I>>(base?: I): IpcSettingsChanged {
    return IpcSettingsChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcSettingsChanged>, I>>(object: I): IpcSettingsChanged {
    const message = createBaseIpcSettingsChanged();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseOverlaySettings(): OverlaySettings {
  return { showWhenInactive: false, showModeText: false, showPttKeyName: false, isMovable: false, x: 0, y: 0 };
}

export const OverlaySettings: MessageFns<OverlaySettings> = {
  encode(message: OverlaySettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.showWhenInactive !== false) {
      writer.uint32(8).bool(message.showWhenInactive);
    }
    if (message.showModeText !== false) {
      writer.uint32(16).bool(message.showModeText);
    }
    if (message.showPttKeyName !== false) {
      writer.uint32(24).bool(message.showPttKeyName);
    }
    if (message.isMovable !== false) {
      writer.uint32(32).bool(message.isMovable);
    }
    if (message.x !== 0) {
      writer.uint32(40).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(48).int32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OverlaySettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverlaySettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.showWhenInactive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.showModeText = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.showPttKeyName = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isMovable = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OverlaySettings {
    return {
      showWhenInactive: isSet(object.showWhenInactive) ? globalThis.Boolean(object.showWhenInactive) : false,
      showModeText: isSet(object.showModeText) ? globalThis.Boolean(object.showModeText) : false,
      showPttKeyName: isSet(object.showPttKeyName) ? globalThis.Boolean(object.showPttKeyName) : false,
      isMovable: isSet(object.isMovable) ? globalThis.Boolean(object.isMovable) : false,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: OverlaySettings): unknown {
    const obj: any = {};
    if (message.showWhenInactive !== false) {
      obj.showWhenInactive = message.showWhenInactive;
    }
    if (message.showModeText !== false) {
      obj.showModeText = message.showModeText;
    }
    if (message.showPttKeyName !== false) {
      obj.showPttKeyName = message.showPttKeyName;
    }
    if (message.isMovable !== false) {
      obj.isMovable = message.isMovable;
    }
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OverlaySettings>, I>>(base?: I): OverlaySettings {
    return OverlaySettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverlaySettings>, I>>(object: I): OverlaySettings {
    const message = createBaseOverlaySettings();
    message.showWhenInactive = object.showWhenInactive ?? false;
    message.showModeText = object.showModeText ?? false;
    message.showPttKeyName = object.showPttKeyName ?? false;
    message.isMovable = object.isMovable ?? false;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseIpcOverlayHello(): IpcOverlayHello {
  return {};
}

export const IpcOverlayHello: MessageFns<IpcOverlayHello> = {
  encode(_: IpcOverlayHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcOverlayHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcOverlayHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcOverlayHello {
    return {};
  },

  toJSON(_: IpcOverlayHello): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcOverlayHello>, I>>(base?: I): IpcOverlayHello {
    return IpcOverlayHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcOverlayHello>, I>>(_: I): IpcOverlayHello {
    const message = createBaseIpcOverlayHello();
    return message;
  },
};

function createBaseIpcSidekickConnected(): IpcSidekickConnected {
  return { port: "" };
}

export const IpcSidekickConnected: MessageFns<IpcSidekickConnected> = {
  encode(message: IpcSidekickConnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.port !== "") {
      writer.uint32(10).string(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcSidekickConnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcSidekickConnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.port = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcSidekickConnected {
    return { port: isSet(object.port) ? globalThis.String(object.port) : "" };
  },

  toJSON(message: IpcSidekickConnected): unknown {
    const obj: any = {};
    if (message.port !== "") {
      obj.port = message.port;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcSidekickConnected>, I>>(base?: I): IpcSidekickConnected {
    return IpcSidekickConnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcSidekickConnected>, I>>(object: I): IpcSidekickConnected {
    const message = createBaseIpcSidekickConnected();
    message.port = object.port ?? "";
    return message;
  },
};

function createBaseIpcSidekickDisconnected(): IpcSidekickDisconnected {
  return {};
}

export const IpcSidekickDisconnected: MessageFns<IpcSidekickDisconnected> = {
  encode(_: IpcSidekickDisconnected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcSidekickDisconnected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcSidekickDisconnected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcSidekickDisconnected {
    return {};
  },

  toJSON(_: IpcSidekickDisconnected): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcSidekickDisconnected>, I>>(base?: I): IpcSidekickDisconnected {
    return IpcSidekickDisconnected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcSidekickDisconnected>, I>>(_: I): IpcSidekickDisconnected {
    const message = createBaseIpcSidekickDisconnected();
    return message;
  },
};

function createBaseIpcRequestRestart(): IpcRequestRestart {
  return {};
}

export const IpcRequestRestart: MessageFns<IpcRequestRestart> = {
  encode(_: IpcRequestRestart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestRestart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestRestart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcRequestRestart {
    return {};
  },

  toJSON(_: IpcRequestRestart): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestRestart>, I>>(base?: I): IpcRequestRestart {
    return IpcRequestRestart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestRestart>, I>>(_: I): IpcRequestRestart {
    const message = createBaseIpcRequestRestart();
    return message;
  },
};

function createBaseIpcRequestExit(): IpcRequestExit {
  return {};
}

export const IpcRequestExit: MessageFns<IpcRequestExit> = {
  encode(_: IpcRequestExit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestExit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestExit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcRequestExit {
    return {};
  },

  toJSON(_: IpcRequestExit): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestExit>, I>>(base?: I): IpcRequestExit {
    return IpcRequestExit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestExit>, I>>(_: I): IpcRequestExit {
    const message = createBaseIpcRequestExit();
    return message;
  },
};

function createBaseIpcRequestUpdate(): IpcRequestUpdate {
  return {};
}

export const IpcRequestUpdate: MessageFns<IpcRequestUpdate> = {
  encode(_: IpcRequestUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcRequestUpdate {
    return {};
  },

  toJSON(_: IpcRequestUpdate): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestUpdate>, I>>(base?: I): IpcRequestUpdate {
    return IpcRequestUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestUpdate>, I>>(_: I): IpcRequestUpdate {
    const message = createBaseIpcRequestUpdate();
    return message;
  },
};

function createBaseIpcRequestUpdateSettings(): IpcRequestUpdateSettings {
  return { settings: undefined, forceLicenseCheck: false };
}

export const IpcRequestUpdateSettings: MessageFns<IpcRequestUpdateSettings> = {
  encode(message: IpcRequestUpdateSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    if (message.forceLicenseCheck !== false) {
      writer.uint32(16).bool(message.forceLicenseCheck);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestUpdateSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestUpdateSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.forceLicenseCheck = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestUpdateSettings {
    return {
      settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined,
      forceLicenseCheck: isSet(object.forceLicenseCheck) ? globalThis.Boolean(object.forceLicenseCheck) : false,
    };
  },

  toJSON(message: IpcRequestUpdateSettings): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    if (message.forceLicenseCheck !== false) {
      obj.forceLicenseCheck = message.forceLicenseCheck;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestUpdateSettings>, I>>(base?: I): IpcRequestUpdateSettings {
    return IpcRequestUpdateSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestUpdateSettings>, I>>(object: I): IpcRequestUpdateSettings {
    const message = createBaseIpcRequestUpdateSettings();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    message.forceLicenseCheck = object.forceLicenseCheck ?? false;
    return message;
  },
};

function createBaseIpcUpdaterStateChanged(): IpcUpdaterStateChanged {
  return { state: 0, progressPct: 0, message: "" };
}

export const IpcUpdaterStateChanged: MessageFns<IpcUpdaterStateChanged> = {
  encode(message: IpcUpdaterStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.progressPct !== 0) {
      writer.uint32(16).uint32(message.progressPct);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcUpdaterStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcUpdaterStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.progressPct = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcUpdaterStateChanged {
    return {
      state: isSet(object.state) ? updaterStateFromJSON(object.state) : 0,
      progressPct: isSet(object.progressPct) ? globalThis.Number(object.progressPct) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: IpcUpdaterStateChanged): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = updaterStateToJSON(message.state);
    }
    if (message.progressPct !== 0) {
      obj.progressPct = Math.round(message.progressPct);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcUpdaterStateChanged>, I>>(base?: I): IpcUpdaterStateChanged {
    return IpcUpdaterStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcUpdaterStateChanged>, I>>(object: I): IpcUpdaterStateChanged {
    const message = createBaseIpcUpdaterStateChanged();
    message.state = object.state ?? 0;
    message.progressPct = object.progressPct ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseIpcUpdateCheckSuccess(): IpcUpdateCheckSuccess {
  return { isNewer: false, latestVersion: "", changelog: "", downloadUrl: "", signatureUrl: "" };
}

export const IpcUpdateCheckSuccess: MessageFns<IpcUpdateCheckSuccess> = {
  encode(message: IpcUpdateCheckSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isNewer !== false) {
      writer.uint32(8).bool(message.isNewer);
    }
    if (message.latestVersion !== "") {
      writer.uint32(18).string(message.latestVersion);
    }
    if (message.changelog !== "") {
      writer.uint32(26).string(message.changelog);
    }
    if (message.downloadUrl !== "") {
      writer.uint32(34).string(message.downloadUrl);
    }
    if (message.signatureUrl !== "") {
      writer.uint32(42).string(message.signatureUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcUpdateCheckSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcUpdateCheckSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isNewer = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.latestVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.changelog = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.downloadUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signatureUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcUpdateCheckSuccess {
    return {
      isNewer: isSet(object.isNewer) ? globalThis.Boolean(object.isNewer) : false,
      latestVersion: isSet(object.latestVersion) ? globalThis.String(object.latestVersion) : "",
      changelog: isSet(object.changelog) ? globalThis.String(object.changelog) : "",
      downloadUrl: isSet(object.downloadUrl) ? globalThis.String(object.downloadUrl) : "",
      signatureUrl: isSet(object.signatureUrl) ? globalThis.String(object.signatureUrl) : "",
    };
  },

  toJSON(message: IpcUpdateCheckSuccess): unknown {
    const obj: any = {};
    if (message.isNewer !== false) {
      obj.isNewer = message.isNewer;
    }
    if (message.latestVersion !== "") {
      obj.latestVersion = message.latestVersion;
    }
    if (message.changelog !== "") {
      obj.changelog = message.changelog;
    }
    if (message.downloadUrl !== "") {
      obj.downloadUrl = message.downloadUrl;
    }
    if (message.signatureUrl !== "") {
      obj.signatureUrl = message.signatureUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcUpdateCheckSuccess>, I>>(base?: I): IpcUpdateCheckSuccess {
    return IpcUpdateCheckSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcUpdateCheckSuccess>, I>>(object: I): IpcUpdateCheckSuccess {
    const message = createBaseIpcUpdateCheckSuccess();
    message.isNewer = object.isNewer ?? false;
    message.latestVersion = object.latestVersion ?? "";
    message.changelog = object.changelog ?? "";
    message.downloadUrl = object.downloadUrl ?? "";
    message.signatureUrl = object.signatureUrl ?? "";
    return message;
  },
};

function createBaseIpcUpdateCheckFailed(): IpcUpdateCheckFailed {
  return {};
}

export const IpcUpdateCheckFailed: MessageFns<IpcUpdateCheckFailed> = {
  encode(_: IpcUpdateCheckFailed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcUpdateCheckFailed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcUpdateCheckFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcUpdateCheckFailed {
    return {};
  },

  toJSON(_: IpcUpdateCheckFailed): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcUpdateCheckFailed>, I>>(base?: I): IpcUpdateCheckFailed {
    return IpcUpdateCheckFailed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcUpdateCheckFailed>, I>>(_: I): IpcUpdateCheckFailed {
    const message = createBaseIpcUpdateCheckFailed();
    return message;
  },
};

function createBaseIpcCurrentValueChanged(): IpcCurrentValueChanged {
  return { value: 0 };
}

export const IpcCurrentValueChanged: MessageFns<IpcCurrentValueChanged> = {
  encode(message: IpcCurrentValueChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(9).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcCurrentValueChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcCurrentValueChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcCurrentValueChanged {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: IpcCurrentValueChanged): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcCurrentValueChanged>, I>>(base?: I): IpcCurrentValueChanged {
    return IpcCurrentValueChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcCurrentValueChanged>, I>>(object: I): IpcCurrentValueChanged {
    const message = createBaseIpcCurrentValueChanged();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseIpcMonitoringAllowedChanged(): IpcMonitoringAllowedChanged {
  return { isAllowed: false };
}

export const IpcMonitoringAllowedChanged: MessageFns<IpcMonitoringAllowedChanged> = {
  encode(message: IpcMonitoringAllowedChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isAllowed !== false) {
      writer.uint32(8).bool(message.isAllowed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcMonitoringAllowedChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcMonitoringAllowedChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isAllowed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcMonitoringAllowedChanged {
    return { isAllowed: isSet(object.isAllowed) ? globalThis.Boolean(object.isAllowed) : false };
  },

  toJSON(message: IpcMonitoringAllowedChanged): unknown {
    const obj: any = {};
    if (message.isAllowed !== false) {
      obj.isAllowed = message.isAllowed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcMonitoringAllowedChanged>, I>>(base?: I): IpcMonitoringAllowedChanged {
    return IpcMonitoringAllowedChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcMonitoringAllowedChanged>, I>>(object: I): IpcMonitoringAllowedChanged {
    const message = createBaseIpcMonitoringAllowedChanged();
    message.isAllowed = object.isAllowed ?? false;
    return message;
  },
};

function createBaseIpcToggleMuteGlobalChanged(): IpcToggleMuteGlobalChanged {
  return { isActive: false };
}

export const IpcToggleMuteGlobalChanged: MessageFns<IpcToggleMuteGlobalChanged> = {
  encode(message: IpcToggleMuteGlobalChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isActive !== false) {
      writer.uint32(8).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcToggleMuteGlobalChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcToggleMuteGlobalChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcToggleMuteGlobalChanged {
    return { isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false };
  },

  toJSON(message: IpcToggleMuteGlobalChanged): unknown {
    const obj: any = {};
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcToggleMuteGlobalChanged>, I>>(base?: I): IpcToggleMuteGlobalChanged {
    return IpcToggleMuteGlobalChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcToggleMuteGlobalChanged>, I>>(object: I): IpcToggleMuteGlobalChanged {
    const message = createBaseIpcToggleMuteGlobalChanged();
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseIpcToggleMuteChanged(): IpcToggleMuteChanged {
  return { keyGroupIndex: 0, isActive: false };
}

export const IpcToggleMuteChanged: MessageFns<IpcToggleMuteChanged> = {
  encode(message: IpcToggleMuteChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyGroupIndex !== 0) {
      writer.uint32(8).uint32(message.keyGroupIndex);
    }
    if (message.isActive !== false) {
      writer.uint32(16).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcToggleMuteChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcToggleMuteChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyGroupIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcToggleMuteChanged {
    return {
      keyGroupIndex: isSet(object.keyGroupIndex) ? globalThis.Number(object.keyGroupIndex) : 0,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
    };
  },

  toJSON(message: IpcToggleMuteChanged): unknown {
    const obj: any = {};
    if (message.keyGroupIndex !== 0) {
      obj.keyGroupIndex = Math.round(message.keyGroupIndex);
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcToggleMuteChanged>, I>>(base?: I): IpcToggleMuteChanged {
    return IpcToggleMuteChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcToggleMuteChanged>, I>>(object: I): IpcToggleMuteChanged {
    const message = createBaseIpcToggleMuteChanged();
    message.keyGroupIndex = object.keyGroupIndex ?? 0;
    message.isActive = object.isActive ?? false;
    return message;
  },
};

function createBaseIpcRequestPlaySfx(): IpcRequestPlaySfx {
  return { sfx: 0 };
}

export const IpcRequestPlaySfx: MessageFns<IpcRequestPlaySfx> = {
  encode(message: IpcRequestPlaySfx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sfx !== 0) {
      writer.uint32(8).uint64(message.sfx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestPlaySfx {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestPlaySfx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sfx = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestPlaySfx {
    return { sfx: isSet(object.sfx) ? globalThis.Number(object.sfx) : 0 };
  },

  toJSON(message: IpcRequestPlaySfx): unknown {
    const obj: any = {};
    if (message.sfx !== 0) {
      obj.sfx = Math.round(message.sfx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestPlaySfx>, I>>(base?: I): IpcRequestPlaySfx {
    return IpcRequestPlaySfx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestPlaySfx>, I>>(object: I): IpcRequestPlaySfx {
    const message = createBaseIpcRequestPlaySfx();
    message.sfx = object.sfx ?? 0;
    return message;
  },
};

function createBaseIpcClientConfigure(): IpcClientConfigure {
  return { currentValueUpdateRateMs: 0, ipcVersion: 0, ipcTag: "" };
}

export const IpcClientConfigure: MessageFns<IpcClientConfigure> = {
  encode(message: IpcClientConfigure, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentValueUpdateRateMs !== 0) {
      writer.uint32(8).uint64(message.currentValueUpdateRateMs);
    }
    if (message.ipcVersion !== 0) {
      writer.uint32(16).uint32(message.ipcVersion);
    }
    if (message.ipcTag !== "") {
      writer.uint32(26).string(message.ipcTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcClientConfigure {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcClientConfigure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentValueUpdateRateMs = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ipcVersion = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipcTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcClientConfigure {
    return {
      currentValueUpdateRateMs: isSet(object.currentValueUpdateRateMs)
        ? globalThis.Number(object.currentValueUpdateRateMs)
        : 0,
      ipcVersion: isSet(object.ipcVersion) ? globalThis.Number(object.ipcVersion) : 0,
      ipcTag: isSet(object.ipcTag) ? globalThis.String(object.ipcTag) : "",
    };
  },

  toJSON(message: IpcClientConfigure): unknown {
    const obj: any = {};
    if (message.currentValueUpdateRateMs !== 0) {
      obj.currentValueUpdateRateMs = Math.round(message.currentValueUpdateRateMs);
    }
    if (message.ipcVersion !== 0) {
      obj.ipcVersion = Math.round(message.ipcVersion);
    }
    if (message.ipcTag !== "") {
      obj.ipcTag = message.ipcTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcClientConfigure>, I>>(base?: I): IpcClientConfigure {
    return IpcClientConfigure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcClientConfigure>, I>>(object: I): IpcClientConfigure {
    const message = createBaseIpcClientConfigure();
    message.currentValueUpdateRateMs = object.currentValueUpdateRateMs ?? 0;
    message.ipcVersion = object.ipcVersion ?? 0;
    message.ipcTag = object.ipcTag ?? "";
    return message;
  },
};

function createBaseIpcServerHello(): IpcServerHello {
  return { ipcVersion: 0, appVersion: 0 };
}

export const IpcServerHello: MessageFns<IpcServerHello> = {
  encode(message: IpcServerHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipcVersion !== 0) {
      writer.uint32(8).uint32(message.ipcVersion);
    }
    if (message.appVersion !== 0) {
      writer.uint32(16).uint32(message.appVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcServerHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcServerHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.ipcVersion = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.appVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcServerHello {
    return {
      ipcVersion: isSet(object.ipcVersion) ? globalThis.Number(object.ipcVersion) : 0,
      appVersion: isSet(object.appVersion) ? globalThis.Number(object.appVersion) : 0,
    };
  },

  toJSON(message: IpcServerHello): unknown {
    const obj: any = {};
    if (message.ipcVersion !== 0) {
      obj.ipcVersion = Math.round(message.ipcVersion);
    }
    if (message.appVersion !== 0) {
      obj.appVersion = Math.round(message.appVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcServerHello>, I>>(base?: I): IpcServerHello {
    return IpcServerHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcServerHello>, I>>(object: I): IpcServerHello {
    const message = createBaseIpcServerHello();
    message.ipcVersion = object.ipcVersion ?? 0;
    message.appVersion = object.appVersion ?? 0;
    return message;
  },
};

function createBaseIpcGuiDeviceChanged(): IpcGuiDeviceChanged {
  return { deviceNameOrUuid: "" };
}

export const IpcGuiDeviceChanged: MessageFns<IpcGuiDeviceChanged> = {
  encode(message: IpcGuiDeviceChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceNameOrUuid !== "") {
      writer.uint32(10).string(message.deviceNameOrUuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcGuiDeviceChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcGuiDeviceChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceNameOrUuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcGuiDeviceChanged {
    return { deviceNameOrUuid: isSet(object.deviceNameOrUuid) ? globalThis.String(object.deviceNameOrUuid) : "" };
  },

  toJSON(message: IpcGuiDeviceChanged): unknown {
    const obj: any = {};
    if (message.deviceNameOrUuid !== "") {
      obj.deviceNameOrUuid = message.deviceNameOrUuid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcGuiDeviceChanged>, I>>(base?: I): IpcGuiDeviceChanged {
    return IpcGuiDeviceChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcGuiDeviceChanged>, I>>(object: I): IpcGuiDeviceChanged {
    const message = createBaseIpcGuiDeviceChanged();
    message.deviceNameOrUuid = object.deviceNameOrUuid ?? "";
    return message;
  },
};

function createBaseIpcAppEnabledStateChanged(): IpcAppEnabledStateChanged {
  return { state: 0 };
}

export const IpcAppEnabledStateChanged: MessageFns<IpcAppEnabledStateChanged> = {
  encode(message: IpcAppEnabledStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcAppEnabledStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcAppEnabledStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcAppEnabledStateChanged {
    return { state: isSet(object.state) ? appEnabledStateFromJSON(object.state) : 0 };
  },

  toJSON(message: IpcAppEnabledStateChanged): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = appEnabledStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcAppEnabledStateChanged>, I>>(base?: I): IpcAppEnabledStateChanged {
    return IpcAppEnabledStateChanged.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcAppEnabledStateChanged>, I>>(object: I): IpcAppEnabledStateChanged {
    const message = createBaseIpcAppEnabledStateChanged();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseIpcRequestSwapActivationMode(): IpcRequestSwapActivationMode {
  return { modes: [] };
}

export const IpcRequestSwapActivationMode: MessageFns<IpcRequestSwapActivationMode> = {
  encode(message: IpcRequestSwapActivationMode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.modes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSwapActivationMode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSwapActivationMode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.modes.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.modes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSwapActivationMode {
    return {
      modes: globalThis.Array.isArray(object?.modes) ? object.modes.map((e: any) => activationModeFromJSON(e)) : [],
    };
  },

  toJSON(message: IpcRequestSwapActivationMode): unknown {
    const obj: any = {};
    if (message.modes?.length) {
      obj.modes = message.modes.map((e) => activationModeToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSwapActivationMode>, I>>(base?: I): IpcRequestSwapActivationMode {
    return IpcRequestSwapActivationMode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSwapActivationMode>, I>>(object: I): IpcRequestSwapActivationMode {
    const message = createBaseIpcRequestSwapActivationMode();
    message.modes = object.modes?.map((e) => e) || [];
    return message;
  },
};

function createBaseIpcRequestSetPushToTalkState(): IpcRequestSetPushToTalkState {
  return { keyGroupIndex: 0, isDown: false };
}

export const IpcRequestSetPushToTalkState: MessageFns<IpcRequestSetPushToTalkState> = {
  encode(message: IpcRequestSetPushToTalkState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyGroupIndex !== 0) {
      writer.uint32(8).uint32(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      writer.uint32(16).bool(message.isDown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSetPushToTalkState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSetPushToTalkState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyGroupIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isDown = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSetPushToTalkState {
    return {
      keyGroupIndex: isSet(object.keyGroupIndex) ? globalThis.Number(object.keyGroupIndex) : 0,
      isDown: isSet(object.isDown) ? globalThis.Boolean(object.isDown) : false,
    };
  },

  toJSON(message: IpcRequestSetPushToTalkState): unknown {
    const obj: any = {};
    if (message.keyGroupIndex !== 0) {
      obj.keyGroupIndex = Math.round(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      obj.isDown = message.isDown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSetPushToTalkState>, I>>(base?: I): IpcRequestSetPushToTalkState {
    return IpcRequestSetPushToTalkState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSetPushToTalkState>, I>>(object: I): IpcRequestSetPushToTalkState {
    const message = createBaseIpcRequestSetPushToTalkState();
    message.keyGroupIndex = object.keyGroupIndex ?? 0;
    message.isDown = object.isDown ?? false;
    return message;
  },
};

function createBaseIpcRequestSetPushToMuteState(): IpcRequestSetPushToMuteState {
  return { keyGroupIndex: 0, isDown: false };
}

export const IpcRequestSetPushToMuteState: MessageFns<IpcRequestSetPushToMuteState> = {
  encode(message: IpcRequestSetPushToMuteState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyGroupIndex !== 0) {
      writer.uint32(8).uint32(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      writer.uint32(16).bool(message.isDown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSetPushToMuteState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSetPushToMuteState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyGroupIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isDown = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSetPushToMuteState {
    return {
      keyGroupIndex: isSet(object.keyGroupIndex) ? globalThis.Number(object.keyGroupIndex) : 0,
      isDown: isSet(object.isDown) ? globalThis.Boolean(object.isDown) : false,
    };
  },

  toJSON(message: IpcRequestSetPushToMuteState): unknown {
    const obj: any = {};
    if (message.keyGroupIndex !== 0) {
      obj.keyGroupIndex = Math.round(message.keyGroupIndex);
    }
    if (message.isDown !== false) {
      obj.isDown = message.isDown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSetPushToMuteState>, I>>(base?: I): IpcRequestSetPushToMuteState {
    return IpcRequestSetPushToMuteState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSetPushToMuteState>, I>>(object: I): IpcRequestSetPushToMuteState {
    const message = createBaseIpcRequestSetPushToMuteState();
    message.keyGroupIndex = object.keyGroupIndex ?? 0;
    message.isDown = object.isDown ?? false;
    return message;
  },
};

function createBaseIpcRequestSetPushToMuteGlobalState(): IpcRequestSetPushToMuteGlobalState {
  return { isDown: false };
}

export const IpcRequestSetPushToMuteGlobalState: MessageFns<IpcRequestSetPushToMuteGlobalState> = {
  encode(message: IpcRequestSetPushToMuteGlobalState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isDown !== false) {
      writer.uint32(8).bool(message.isDown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestSetPushToMuteGlobalState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestSetPushToMuteGlobalState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isDown = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestSetPushToMuteGlobalState {
    return { isDown: isSet(object.isDown) ? globalThis.Boolean(object.isDown) : false };
  },

  toJSON(message: IpcRequestSetPushToMuteGlobalState): unknown {
    const obj: any = {};
    if (message.isDown !== false) {
      obj.isDown = message.isDown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestSetPushToMuteGlobalState>, I>>(
    base?: I,
  ): IpcRequestSetPushToMuteGlobalState {
    return IpcRequestSetPushToMuteGlobalState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestSetPushToMuteGlobalState>, I>>(
    object: I,
  ): IpcRequestSetPushToMuteGlobalState {
    const message = createBaseIpcRequestSetPushToMuteGlobalState();
    message.isDown = object.isDown ?? false;
    return message;
  },
};

function createBaseIpcRequestToggleMuteGlobal(): IpcRequestToggleMuteGlobal {
  return {};
}

export const IpcRequestToggleMuteGlobal: MessageFns<IpcRequestToggleMuteGlobal> = {
  encode(_: IpcRequestToggleMuteGlobal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestToggleMuteGlobal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestToggleMuteGlobal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IpcRequestToggleMuteGlobal {
    return {};
  },

  toJSON(_: IpcRequestToggleMuteGlobal): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestToggleMuteGlobal>, I>>(base?: I): IpcRequestToggleMuteGlobal {
    return IpcRequestToggleMuteGlobal.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestToggleMuteGlobal>, I>>(_: I): IpcRequestToggleMuteGlobal {
    const message = createBaseIpcRequestToggleMuteGlobal();
    return message;
  },
};

function createBaseIpcRequestToggleMute(): IpcRequestToggleMute {
  return { keyGroupIndex: 0 };
}

export const IpcRequestToggleMute: MessageFns<IpcRequestToggleMute> = {
  encode(message: IpcRequestToggleMute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyGroupIndex !== 0) {
      writer.uint32(8).uint32(message.keyGroupIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpcRequestToggleMute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpcRequestToggleMute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyGroupIndex = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpcRequestToggleMute {
    return { keyGroupIndex: isSet(object.keyGroupIndex) ? globalThis.Number(object.keyGroupIndex) : 0 };
  },

  toJSON(message: IpcRequestToggleMute): unknown {
    const obj: any = {};
    if (message.keyGroupIndex !== 0) {
      obj.keyGroupIndex = Math.round(message.keyGroupIndex);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpcRequestToggleMute>, I>>(base?: I): IpcRequestToggleMute {
    return IpcRequestToggleMute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpcRequestToggleMute>, I>>(object: I): IpcRequestToggleMute {
    const message = createBaseIpcRequestToggleMute();
    message.keyGroupIndex = object.keyGroupIndex ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
